\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{comment}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}


\usepackage[style=ieee]{biblatex}
\addbibresource[datatype=bibtex]{bibliography/documentation.bib}
\addbibresource[datatype=bibtex]{bibliography/references.bib}

\input{../Comments}
\input{../Common}

\begin{document}

\title{System Verification and Validation Plan for \progname{}}
\author{\authname}
\date{November 4, 2024}

\maketitle

\pagenumbering{roman}

\section*{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
  \toprule {\bf Date} & {\bf Version} & {\bf Notes}      \\
  \midrule
  2024/11/04          & 1.0           & Initial VnV Plan \\
  \midrule
  2025/03/11          & 1.1           & Unit tests added \\
  \midrule
  2025/03/24          & 1.2           & Refinements made based on critique \\
  \midrule
  2025/03/25          & 1.3           & Removed references to features we are no longer implemented; Fixed formatting issues \\
  \midrule
  2025/03/28          & 1.4           & Made minor changes to test based on VnVReport changes \\
  \bottomrule
\end{tabularx}

\newpage

\tableofcontents

\listoftables

\newpage

\pagenumbering{arabic}

The purpose of this Verification and Validation document is to outline the testing process we'll use to make sure our project meets all its requirements and functions correctly. Verification checks that we're building the product according to our design, while validation ensures the product meets the users' needs and performs as expected. This document will describe both functional and non-functional tests, which help confirm that the project is reliable, safe, and easy to use. By following this VnV plan, we can identify and fix any issues early, ensuring the final product is high-quality and ready for users.

\section{General Information}
The section covers general information about the AR application, \textit{Realm}, and this document.

\subsection{Summary}

The software being tested is ``Realm'', an AR touring platform. The platform allows users to place AR objects in the real world for others to see and allows organizations to create AR tours to provide users with high-quality experiences. This document will include tests for all requirements as well as the design plan for validation and verification.

\subsection{Objectives}

The primary objectives for the validation and verification of Realm are as follows: \\

\begin{itemize}
  \item \textbf{Ensure accuracy of AR functionality}: One of our core goals is to build confidence in the AR features' correctness, confirming that the AR objects can be placed effectively. We also want to ensure that overlays align accurately with real-world elements, and behave as intended in various lighting and spatial conditions. \\

  \item \textbf{Verify usability and engagement}: Usability testing will focus on confirming that users can seamlessly navigate through the app, and interact with AR objects and other users. This includes ease of use, intuitiveness of the AR controls, and overall satisfaction with the social sharing features. \\

  \item \textbf{Data security and privacy assurance}: Given the app's AR elements, it's essential to ensure that all user data, including images and interaction history, is securely managed and protected from unauthorized access. \\
\end{itemize}

Due to limited resources, the following objectives will not be prioritized in this phase: \\

\begin{itemize}
  \item \textbf{Universal device compatibility}: Testing will focus on popular AR-enabled devices, but comprehensive performance validation across all devices and OS versions is outside the scope of this initial release. \\

  \item \textbf{Verification of third-party libraries}: The project relies on AR libraries and frameworks from external providers. We assume these libraries have been validated by their developers, allowing us to concentrate on verifying custom AR functionality and app-specific features. \\
\end{itemize}

\subsection{Challenge Level and Extras}

The challenge level for the Realm project is \textbf{general}. The extras that are going to be tackled in this project are \textbf{user documentation} and \textbf{usability testing}. We chose these two as they are deemed useful to the user's interaction with our app. The user documentation will help the user to learn to use the app simply, and the usability testing will help us to deliver a product that is acceptable and tailored to the use case of our users.

\subsection{Relevant Documentation}

This document contains information garnered from all the previous documentation referenced below:

\begingroup
\raggedright
\renewcommand{\refname}{}
\printbibliography
\endgroup

\begin{itemize}
  \item The Problem Statement is a good reference to understand the context in which all of the requirements come from. The plans in this document should reflect the goals outlined in the Problem Statement.
  \item The Development Plan has a list of team member roles which are should be considered when writing about a team member's testing role.
  \item The SRS contains all of the functional (FR) and non-functional (NFR) requirements that were found in the elicitation process and those that were found after the initial version. This document strives to have a plan for each of these requirements.
  \item The Hazard Analysis has many considerations for potential hazards and mitigation strategies to reduce the project risk. There are many new FRs and NFRs that were derived from this analysis that need to be verified and validated.
  \item The VnV Plan itself is also subject to verification as outlined by the \nameref{ssub:vnv_plan_verificaiton_plan} sub-section.
\end{itemize}

\newrefsection

\section{Plan}
\label{sub:plan}

This section outlines the structured plan for verifying and validating our project at each stage of development. It first lists the roles of the team members involved in verification, the strategies for ensuring the accuracy of our requirements, design, and implementation, as well as the tools we'll use for automated testing. Each part is designed to ensure our project meets quality standards and fulfills its intended purpose.

\newpage
\subsection{Verification and Validation Team}

\begin{table}[h!]
  \centering
  \begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    \textbf{Team Member} & \textbf{Role}              & \textbf{Responsibilities}                                                                                  \\ \hline
    Russell              & Configuration Specialist   & Configure Roslyn analyzers for static code analysis, ensuring they meet project needs                      \\ \hline
    Abdul                & Dynamic Testing Lead       & Research and implement the Unity Test Framework for Unity Editor Mode, focusing on dynamic testing         \\ \hline
    Avanish              & Dynamic Testing Assistant  & Support Abdul in implementing the Unity Test Framework for Play Mode, ensuring comprehensive test coverage \\ \hline
    Rafey                & Static Analysis Specialist & Select and configure a static analysis tool (e.g., SonarQube), manage static code quality checks           \\ \hline
  \end{tabularx}
  \caption{Verification and Validation Testing Team Roles and Responsibilities}
\end{table}

\subsection{SRS Verification Plan}

For the SRS Verification Plan, we will adopt a structured approach that includes peer reviews, systematic checks, and feedback from our TA. Initially, ad hoc feedback will be gathered from team members to identify any immediate issues or ambiguities in the SRS. We will then conduct a detailed review session where each team member inspects specific sections of the document using a predefined checklist focused on clarity, completeness, and alignment with project goals. We will also meet with our TA to discuss and gather further feedback. An issue tracker will be used to document all feedback, allowing us to systematically address and resolve identified issues.

\subsection{Design Verification Plan}

\begin{itemize}
  \item Internal Team Review
  \item Peer Review
  \item TA Review
  \item Requirements Coverage Check
\end{itemize}

\subsection{Verification and Validation Plan Verification Plan}
\label{ssub:vnv_plan_verificaiton_plan}

Once all the plans outlined in this section (\nameref{sub:plan}) are completed, they go will through a review process such that components that have no validation/verification method are discovered. The following process will take place:

\begin{enumerate}
  \item Initial internal review by all group members
        \begin{itemize}
          \item Before the deadline for this document, the group will meet to look over the entire document in the search for components of the project that were overlooked in terms of testing.
          \item A checklist of all the functional and non-functional requirements from the SRS will be used to ensure each of them have a plan to be tested.
          \item All plans in this sub-sections will be checked against the grading rubric. This will act as a checklist for the expected level of detail for each plan.
        \end{itemize}
  \item Peer-Review by an external group
        \begin{itemize}
          \item As part of this deliverable another group will look over the plans from an outside perspective and give feedback on components we may have missed or were not sufficiently covered.
          \item These suggestions will be made through GitHub Issues on the repo.
        \end{itemize}
  \item TA review
        \begin{itemize}
          \item When the TA reviews this deliverable, they will provide feedback for plans that they believe could use some reconstruction.
        \end{itemize}
\end{enumerate}



\subsection{Implementation Verification Plan}

The primary method of validation for the implementation of the system will be the functional, non-functional, and unit tests described in this document. In addition to the static testing and code review specified in the non-functional tests, we will have a code walkthrough for each module to verify adherence to the design, and the completeness of the implementation. In these walkthroughs we will use our MIS as a checklist and go through module implementations checking off correctly implemented elements.

\subsection{Automated Testing and Verification Tools}

Refer to \href{https://github.com/russellrd/realm/blob/main/docs/DevelopmentPlan/DevelopmentPlan.pdf}{section 10 of the development plan} for the list of tools. We will use the NUnit-based Unity Testing framework for unit testing and code coverage metrics. Continuous testing will be done by GitHub actions using Unity Builder and Unity Test Runner from the GameCI open source project.

\subsection{Software Validation Plan}

To validate the software throughout development, we will hold bi-weekly developer meetings. In each meeting, members will present their additions to the codebase and explain how these changes impact the functionality of the targeted components. Each team member will provide a walkthrough of the modified component through a live demo. During these meetings, the team will also ensure that no functional requirements have been inadvertently removed. \\

To further validate that all components function as intended, we will use formal methods, which include a suite of test cases, user testing, and surveys. \\

The suite of test cases will consist of \textit{unit tests}, \textit{module tests}, and \textit{system tests}, designed to verify that each component and the overall system meet functionality requirements. \\

User testing will be conducted by individuals outside the development team, and results will be evaluated using checklists based on the functional and non-functional requirements outlined in the Software Requirements Specification (SRS). \\

Finally, surveys will be administered to test users, allowing them to provide feedback on user experience and satisfaction with the software's functionality. \\

\section{System Tests}
This section contains the descriptions of all system tests spanning functional and non-functional aspects of the application.

\subsection{Tests for Functional Requirements}
This section focuses on test cases pertaining to the functional requirements.

\subsubsection{Realm Testing}

\begin{enumerate}


  \item \textbf{Name:} Validate AR Object Perspective Adjustment \label{itm:Test-RI1} \\
        \textbf{Test ID:} Test-RI1 \\
        \textbf{Type:} Functional, Manual \\
        \textbf{Initial State:} Realm interface is open, AR objects are displayed in the user's vicinity on the camera feed. \\
        \textbf{Input/Condition:} Tester changes their position and angle in relation to an AR object. \\
        \textbf{Output/Result:} The AR object adjusts perspective appropriately, reflecting the new camera position and angle. \\ \textbf{How test will be performed:} The tester will move around the AR object, observing whether it adjusts in real-time and maintains correct perspective relative to the user's view.

  \item \textbf{Name:} Validate AR Object Clutter Management \label{itm:Test-RI2} \\
        \textbf{Test ID:} Test-RI2 \\
        \textbf{Type:} Functional, Manual \\
        \textbf{Initial State:} Realm interface is open, tester is in an area with overlapping AR object instances \\
        \textbf{Input/Condition:} Tester moves camera over a crowded area where multiple AR objects are present. \\
        \textbf{Output/Result:} The interface selectively displays a manageable number of AR objects without overwhelming the user's view. \\ \textbf{How test will be performed:} Tester observes the interface to confirm only a few objects are displayed at once, reducing clutter in the view.

  \item \textbf{Name:} Validate AR Object Placement Accuracy \label{itm:Test-RI3} \\
        \textbf{Test ID:} Test-RI3 \\
        \textbf{Type:} Functional, Automated and Manual \\
        \textbf{Initial State:} Realm interface is open, test AR object instance is nearby \\
        \textbf{Input/Condition:} Test AR object instance is placed with a known alignment in the real world, and reference screenshots \\
        \textbf{Output/Result:} Test AR object appears in correct position and orientation as expected from the known alignment and reference screenshots, position also matches stored object instance data \\
        \textbf{How test will be performed:} Automated tests will compare object instance data, while a manual test will involve the tester visually confirming the position accuracy in the camera view.

  \item \textbf{Name:} Validate Object Placement Workflow Control \label{itm:Test-RI6} \\
        \textbf{Test ID:} Test-RI6 \\
        \textbf{Type:} Functional, Manual \\
        \textbf{Initial State:} Realm interface is open. \\
        \textbf{Input/Condition:} Tester attempts to access the object placement workflow via the provided control. \\
        \textbf{Output/Result:} Tester is successfully redirected to the object placement workflow. \\
        \textbf{How test will be performed:} Tester selects the object placement control and verifies redirection to the appropriate workflow screen.

  \item \textbf{Name:} Validate Nearby Tour Indication \label{itm:Test-RI8} \\
        \textbf{Test ID:} Test-RI8 \\
        \textbf{Type:} Functional, Manual \\
        \textbf{Initial State:} Realm interface is open, tester is near the starting point of a tour. \\
        \textbf{Input/Condition:} Tester moves within range of the tour start point. \\
        \textbf{Output/Result:} The interface displays a clear indication of the nearby tour and a link to the tour preview. \\
        \textbf{How test will be performed:} Tester observes if the indication and link appear when near the tour start point.

  \item \textbf{Name:} Validate Hazard Warning \label{itm:Test-RI9} \\
        \textbf{Test ID:} Test-RI9 \\
        \textbf{Type:} Functional, Manual \\
        \textbf{Initial State:} Realm interface is open, tester is approaching a real-world hazard. \\
        \textbf{Input/Condition:} Tester moves closer to a hazard in real space. \\
        \textbf{Output/Result:} Interface displays a clear warning when user approaches the hazard. \\
        \textbf{How test will be performed:} Tester approaches a wall with the realm interface open, and verifies that a warning appears.

  \item \textbf{Name:} Validate Offline Mode for Interactive Components \label{itm:Test-RI10} \\
        \textbf{Test ID:} Test-RI10 \\
        \textbf{Type:} Functional, Manual \\
        \textbf{Initial State:} Realm interface is open and disconnected from the internet. \\
        \textbf{Input/Condition:} Tester attempts to interact with various components of the interface in offline mode. \\
        \textbf{Output/Result:} Interactive components function normally, but location-based features are disabled. \\
        \textbf{How test will be performed:} Tester verifies the unavailability of object placement, maps, and other internet-dependent features.

\end{enumerate}

\subsubsection{Object Placement Testing}

\begin{enumerate}


  \item \textbf{Name:} Validate Object Selection Stage \label{itm:Test-OP1} \\
        \textbf{Test ID:} Test-OP1 \\
        \textbf{Type:} Functional, Manual \\
        \textbf{Initial State:} Tester has progressed object placement workflow to object selection stage \\
        \textbf{Input/Condition:} Tester selects object from one of: inventory, new prompt generation \\
        \textbf{Output/Result:} Interface successfully proceeds to realm interface with the selected object \\
        \textbf{How test will be performed:} Tester initiates object placement workflow and progresses to object selection step. They then use one of the object selection methods to select an object and validate that the interface moves on to the realm interface with the selected object. They select the option to return to object selection, and repeat the process for all object selection methods.

  \item \textbf{Name:} Validate Object Placement Stage \label{itm:Test-OP3} \\
        \textbf{Test ID:} Test-OP3 \\
        \textbf{Type:} Functional, Manual \\
        \textbf{Initial State:} Tester has progressed object placement workflow object placement stage \\
        \textbf{Input/Condition:} Tester rotates, resizes, and translates the object in real space, then confirms placement. \\
        \textbf{Output/Result:} Rotation, resizing, and translating are all functional, and the AR object is positioned accurately in real space with the correct orientation, aligning with the tester's intent. \\
        \textbf{How test will be performed:} Tester initiates object placement workflow and progresses to object placement step. Tester rotates, resizes, and translates the object, verifying visually that it appears in the intended location and orientation in the real-world view, and finally confirms the placement of the object.

  \item \textbf{Name:} Validate Object Instance Storage \label{itm:Test-OP4} \\
        \textbf{Test ID:} Test-OP4 \\
        \textbf{Type:} Functional, Manual \\
        \textbf{Initial State:} Tester has just placed an AR object instance \\
        \textbf{Input/Condition:} Tester checks the AR object instance database \\
        \textbf{Output/Result:} The AR object instance that the tester placed is present with correct details, including object type, position, and orientation. \\
        \textbf{How test will be performed:} Tester completes the object placement workflow then checks the AR object instance database and verifies the presence and correctness of their newly created object instance.
        
  \item \textbf{Name:} Validate Area Based Placement Limit \label{itm:Test-OP5} \\
        \textbf{Test ID:} Test-OP5 \\
        \textbf{Type:} Functional, Automated and Manual \\
        \textbf{Initial State:} Test user has sufficient AR object instances recorded to reach the object placement limit of an area  \\
        \textbf{Input/Condition:} Tester attempts to place another object in the same area \\
        \textbf{Output/Result:} System prevents additional placements once the area limit is reached, displaying a relevant warning. \\
        \textbf{How test will be performed:} Automated test script creates AR object instance entries in database to reach limit. Tester manually attempts to place another object in selected area, and validates that they are prevented from doing so, and are presented with a warning.

  \item \textbf{Name:} Validate Time Based Placement Limit \label{itm:Test-OP6} \\
        \textbf{Test ID:} Test-OP6 \\
        \textbf{Type:} Functional, Automated and Manual \\
        \textbf{Initial State:} Test user has sufficient AR object instances recorded to reach the time-based object placement limit for a user \\
        \textbf{Input/Condition:} Tester attempts to place another object within a short period \\
        \textbf{Output/Result:} System restricts further placements once the time-based limit is reached, displaying a relevant warning. \\
        \textbf{How test will be performed:} Automated test script creates AR object instance entries in database to reach limit. Tester manually attempts to place another object within a short period, and validates that they are prevented from doing so, and are presented with a warning.

  \item \textbf{Name:} Validate Automated Retry for Failed Object Storage \label{itm:Test-OP7} \\
        \textbf{Test ID:} Test-OP7 \\
        \textbf{Type:} Functional, Automated \\
        \textbf{Initial State:} System is running, with simulated conditions preventing initial object storage (e.g., network issues). \\
        \textbf{Input/Condition:} User places an object, but initial storage attempt fails due to simulated conditions. \\
        \textbf{Output/Result:} System automatically retries object storage until success or retry limit reached. \\
        \textbf{How test will be performed:} Simulate a storage failure on the initial attempt, monitoring logs to confirm retry attempts are made until storage is successful, validating the success scenario. Repeat this process, but simulate continued storage failure, and verify that the number of retries attempted is equal to the retry limit.

\end{enumerate}

\subsubsection{Database Testing}

\begin{enumerate}

  \item \textbf{Name:} Validate Periodic Database Backup \label{itm:Test-DB1} \\
        \textbf{Test ID:} Test-DB1 \\
        \textbf{Type:} Functional, Automated \\
        \textbf{Initial State:} System is running, database is available, periodic backup is set up. \\
        \textbf{Input/Condition:} Periodic backup run is completed.  \\
        \textbf{Output/Result:} Automated monitor verifies that the database backup is present and correct.  \\
        \textbf{How test will be performed:} An automated monitor will wait for periodic backups, then restore the database from the backup in a sandbox environment and check that the data is present as expected.

  \item \textbf{Name:} Validate Database Encryption \label{itm:Test-DB2} \\
        \textbf{Test ID:} Test-DB2 \\
        \textbf{Type:} Functional, Automated \\
        \textbf{Initial State:} System is running, database is available. \\
        \textbf{Input/Condition:} Command to check encryption status is inputted into DBMS for all databases \\
        \textbf{Output/Result:} DBMS response shows that all databases are encrypted \\
        \textbf{How test will be performed:} Will depend on the database platform used, for example on SQL Server the following query would be ran, and the output would be checked: \\
        SELECT db\_name(database\_id), encryption\_state \\
        FROM sys.dm\_database\_encryption\_keys;

\end{enumerate}

\subsubsection{Tour Management}

This section focuses on testing the \textit{Organization User} side of the tours functionality within the app. This includes creating, modifying, and publishing tours so that \textit{General Users} can use them. The main requirement for tour management is the ability to add metadata and objects to an area (\textit{TM-FR4}) which is covered by \textit{Test-TM3} and \textit{Test-TM8}. All the other functional requirements from the Tour Management (TM) section in the SRS \cite{SRS} have at least one test plan below.

\begin{enumerate}

  \item
        \textbf{Name:} \textit{Organization Users} can access tour management screen \label{itm:Test-TM1} \\
        \textbf{Test ID:} Test-TM1 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{Organization User}. \\
        \textbf{Input:} User attempts to navigate to tour management screen. \\
        \textbf{Output:} The tour management screen is reachable. \\
        \textbf{Test Case Derivation:} Only users who are part of a verified organization will have the ability to create/edit/delete tours for their organization. \textit{Organization Users} should have be able to access the tour management screen. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{Organization User} and attempt to see the tour management screen in the navigation.

  \item
        \textbf{Name:} \textit{General Users} can NOT access the tour management screen \label{itm:Test-TM2} \\
        \textbf{Test ID:} Test-TM2 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{General User}. \\
        \textbf{Input:} User attempts to navigate to tour management screen. \\
        \textbf{Output:} The tour management screen is hidden from user. \\
        \textbf{Test Case Derivation:} Only users who are part of a verified organization will have the ability to create/edit/delete tours for their organization. \textit{General Users} should not have the ability to do any tour management. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{General User} and attempt to see the tour management screen in the navigation.

  \item
        \textbf{Name:} \textit{Organization Users} can create a customized tour \label{itm:Test-TM3} \\
        \textbf{Test ID:} Test-TM3 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{Organization User}, on tour management screen. \\
        \textbf{Input:} User attempts to create a tour by inputting all the information described in \textit{TM-FR4} and placing one of each type of object in the environment. \\
        \textbf{Output:} The tour is successfully created with the correct data. \\
        \textbf{Test Case Derivation:} \textit{Organization Users} should be able to create customized tours with metadata and objects placed along a specified path for a \textit{General User} to follow. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{Organization User} and attempt to create a tour using dummy data that fits the input constraints. They will check to see if the data was set correctly.

  \item
        \textbf{Name:} \textit{Organization Users} can create a tour as a draft \label{itm:Test-TM4} \\
        \textbf{Test ID:} Test-TM4 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{Organization User}, on tour management screen. \\
        \textbf{Input:} User attempts to create a tour by inputting all the information described in \textit{TM-FR4} and selects the option to save as a draft. \\
        \textbf{Output:} The tour is successfully created as a draft. \\
        \textbf{Test Case Derivation:} \textit{Organization Users} should be able to create customized tours but not release it directly to the public. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{Organization User} and attempt to create a tour using dummy data that fits the input constraints. They will then select the option at the end to save it as a draft.

  \item
        \textbf{Name:} \textit{Organization Users} can create a tour and directly publish it \label{itm:Test-TM5} \\
        \textbf{Test ID:} Test-TM5 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{Organization User}, on tour management screen. \\
        \textbf{Input:} User attempts to create a tour by inputting all the information described in \textit{TM-FR4} and selects the option to publish the tour. \\
        \textbf{Output:} The tour is successfully created and published. \\
        \textbf{Test Case Derivation:} \textit{Organization Users} should be able to create customized tours and release it directly to the public. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{Organization User} and attempt to create a tour using dummy data that fits the input constraints. They will then select the option at the end to publish it.

  \item
        \textbf{Name:} \textit{Organization Users} can publish a draft tour \label{itm:Test-TM6} \\
        \textbf{Test ID:} Test-TM6 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{Organization User}, on tour management screen, and has a draft tour. \\
        \textbf{Input:} User navigates to the draft tour and selects publish option. \\
        \textbf{Output:} The tour is successfully published. \\
        \textbf{Test Case Derivation:} \textit{Organization Users} should be able to take draft tours that they have previously worked on and publish them for use by \textit{General Users}. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{Organization User}, publish a draft tour and look to see if it was released successfully.

  \item
        \textbf{Name:} \textit{Organization Users} can preview one of their tours \label{itm:Test-TM7} \\
        \textbf{Test ID:} Test-TM7 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{Organization User}, on tour management screen, and has a tour. \\
        \textbf{Input:} User navigates to the tour and selects the preview option. \\
        \textbf{Output:} The tour can be previewed through the lens of what a \textit{General User} would see. \\
        \textbf{Test Case Derivation:} \textit{Organization Users} should be able see what their tour will end up looking like when \textit{General Users} eventually use them. This could expose any mistakes in the layout of the tour that can be fixed before release. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{Organization User}, attempt to preview a tour, and see if the interface is accurately showing the expected tour.

  \item
        \textbf{Name:} \textit{Organization Users} can edit one of their tours \label{itm:Test-TM8} \\
        \textbf{Test ID:} Test-TM8 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{Organization User}, on tour management screen, and has a tour. \\
        \textbf{Input:} User navigates to the tour they wish to edit, selects the edit option and changes all the inputs described in \textit{TM-FR4}. \\
        \textbf{Output:} The tour is successfully edited with the correct data. \\
        \textbf{Test Case Derivation:} \textit{Organization Users} should be able to edit a tour's metadata and modify the objects placed along a specified path. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{Organization User} and attempt to edit a tour using new dummy data that fits the input constraints. They will check to see if the data was set correctly.

\end{enumerate}

\subsubsection{Touring}

This section focuses on testing the \textit{General User} side of the tours functionality within the app. This includes the various ways a user can find tours (\textit{TR-FR2}). There are also requirements for previewing a tour (\textit{TR-FR3}) and using the view seen when actually going on a tour (\textit{TR-FR4}). All the other functional requirements from the Touring (TR) section in the SRS \cite{SRS} have at least one test plan below.

\begin{enumerate}

  \item
        \textbf{Name:} \textit{General Users} can access the touring screen \label{itm:Test-TR1} \\
        \textbf{Test ID:} Test-TR1 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{General User}. \\
        \textbf{Input:} User attempts to navigate to the touring screen. \\
        \textbf{Output:} The touring screen is reachable. \\
        \textbf{Test Case Derivation:} Only users who are \textit{General Users} will have the ability to go on tours. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{General User} and attempt to see the touring screen in the navigation.

  \item
        \textbf{Name:} \textit{Organization Users} can NOT access the touring screen \label{itm:Test-TR2} \\
        \textbf{Test ID:} Test-TR2 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{Organization User}. \\
        \textbf{Input:} User attempts to navigate to touring screen. \\
        \textbf{Output:} The touring screen is hidden from user. \\
        \textbf{Test Case Derivation:} Only users who are \textit{General Users} will have the ability to go on tours. \textit{Organization Users} should have no option to do any touring. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{Organization User} and attempt to see the touring screen in the navigation.

  \item
        \textbf{Name:} \textit{General Users} can preview a tour \label{itm:Test-TR3} \\
        \textbf{Test ID:} Test-TR3 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as \textit{General User}, on touring screen, and a tour exits. \\
        \textbf{Input:} User finds a tour and attempts to preview it. \\
        \textbf{Output:} User can see the information described in \textit{TR-FR3}. \\
        \textbf{Test Case Derivation:} \textit{General Users} should be able to preview a tour to see information like the distance and route before actually starting it. They may want to determine if the tour fits with their schedule. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{General User} and attempt to preview a tour. They will check to see if all the data outlined in \textit{TR-FR3} is present.

  \item
        \textbf{Name:} \textit{General Users} can find a tour through the tour list interface \label{itm:Test-TR4} \\
        \textbf{Test ID:} Test-TR4 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{General User}, on touring screen, and a public tour exists. \\
        \textbf{Input:} User navigates to the tour list interface, and searches for a tour belonging to an organization. \\
        \textbf{Output:} The tour has been found. \\
        \textbf{Test Case Derivation:} \textit{General Users} should be able to find tours through one page where the tours can grouped together by organization or location. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{General User} and attempt to find a tour through the tour list interface that belongs to an organization.

  \item
        \textbf{Name:} \textit{General Users} can find a tour through a push notification when in proximity to a tour area in the real-world \label{itm:Test-TR5} \\
        \textbf{Test ID:} Test-TR5 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{General User} but out of the app itself, push notifications are turned on, and their is a tour in the area. \\
        \textbf{Input:} User goes close to a tour area in the real-world. \\
        \textbf{Output:} A push notification appears on the user's phone indicating that a tour is nearby and prompts them to preview it. \\
        \textbf{Test Case Derivation:} \textit{General Users} should be able to find tours that they might not know about by just being in proximity to it. This will expose the user to tours they may enjoy going on even when the app is not in their mind at that moment. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{General User} and close the app. They will then walk close to a tour location in the real-world and check to see if they get a push notification.

  \item
        \textbf{Name:} \textit{General Users} can find a tour through a QR code \label{itm:Test-TR6} \\
        \textbf{Test ID:} Test-TR6 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{General User} but in their phone's camera app and they have a tour QR code. \\
        \textbf{Input:} User scans the QR code through the camera app. \\
        \textbf{Output:} The camera app opens \textit{Realm} to the preview of the corresponding tour. \\
        \textbf{Test Case Derivation:} \textit{General Users} should be able to find tours in the app using a QR code sticker located in the real-world at the start of a tour. This allows them to quickly find the tour without searching through the list. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{General User} and open the camera app. They will scan the QR code and see if the preview of the tour opens up in the \textit{Realm} app properly.

  \item
        \textbf{Name:} \textit{General Users} can switch between the map and AR view in a tour \label{itm:Test-TR7} \\
        \textbf{Test ID:} Test-TR7 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{General User}, started a tour, and is in map view. \\
        \textbf{Input:} User selects option to change tour view to AR view and back. \\
        \textbf{Output:} The app switches the view to AR view and then back to map view. \\
        \textbf{Test Case Derivation:} \textit{General Users} should be able see tours through the two views and switch between them at any point in time. The AR view is more immersive but users may want to see their progress on a larger scale through the map. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{General User} and start a tour. They will try switching the tour view and see if the view is actually changed.

  \item
        \textbf{Name:} \textit{General Users} can see the map tour view \label{itm:Test-TR8} \\
        \textbf{Test ID:} Test-TR8 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{General User} and started a tour \\
        \textbf{Input:} User selects map view. \\
        \textbf{Output:} The user can see the map with the properties described in \textit{TR-FR4.1}. \\
        \textbf{Test Case Derivation:} \textit{General Users} should be able to view their progress in a tour through a map of the route with information that will aid in their understanding. They should be able to see their location overlaid on the map along with the \textit{AR objects} locations. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{General User} and start a tour. They will open the map view and check to see if all properties of maps outlined in \textit{TR-FR4.1} are present.

  \item
        \textbf{Name:} \textit{General Users} can see the AR tour view \label{itm:Test-TR9} \\
        \textbf{Test ID:} Test-TR9 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in as a \textit{General User} and started a tour \\
        \textbf{Input:} User selects AR view. \\
        \textbf{Output:} The user can see an AR view with the properties described in \textit{TR-FR4.2}. \\
        \textbf{Test Case Derivation:} \textit{General Users} should have a more immersive interface similar to the realm interface used in the main app instead of having just a map. They should be able to see the \textit{AR objects} superimposed on their screen with the historical information associated with them. \\
        \textbf{How test will be performed:} A tester will manually login as a \textit{General User} and start a tour. They will open the AR view and check to see if all properties of maps outlined in \textit{TR-FR4.2} are present.

\end{enumerate}

\subsubsection{Profile Testing}
\label{sec:profile_screen_testing}

The Profile Screen Testing focuses on verifying user interactions related to profile management, password changes, and viewing of profile data. These tests ensure that users can efficiently manage their profile settings and view relevant information, which is critical for maintaining user engagement and security.

\begin{enumerate}
  \item \textbf{Name:} {Validate User Authentication} \label{itm:Test-PS1}\\
        \textbf{Test ID:} Test-PS1\\
        \textbf{Control:} Automated \\
        \textbf{Initial State:} App launched, login screen displayed. \\
        \textbf{Input:} User enters valid credentials. \\
        \textbf{Output:} The expected result is that the user successfully logs in and is redirected to their profile page. \\
        \textbf{Test Case Derivation:} This test is to ensure the system authenticates users with valid credentials.\\
        \textbf{How test will be performed:} Through an automated script that inputs valid user credentials and checks if redirection to the profile page is successful.

  \item \textbf{Name:} {Password Change Functionality} \label{itm:Test-PS2}\\
        \textbf{Test ID:} Test-PS2\\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in, on profile settings page. \\
        \textbf{Input:} User inputs new password and confirms. \\
        \textbf{Output:} The expected result is that the system updates the password and provides a confirmation message. \\
        \textbf{Test Case Derivation:} To verify that the system allows users to change their password securely. \\
        \textbf{How test will be performed:} Tester manually changes the password and checks for confirmation of the change.

  \item \textbf{Name:} {View Profile Information} \label{itm:Test-PS3}\\
        \textbf{Test ID:} Test-PS3\\
        \textbf{Control:} Automated \\
        \textbf{Initial State:} User logged in, on profile page. \\
        \textbf{Input:} None. \\
        \textbf{Output:} The expected result is that profile information (username, password, profile picture, status) is displayed correctly. \\
        \textbf{Test Case Derivation:} Confirm that all user profile information is retrievable and displayed correctly. \\
        \textbf{How test will be performed:} Automated test that logs in as a user and verifies that all profile information is displayed as expected.

  \item \textbf{Name:} {Access Help Page} \label{itm:Test-PS4}\\
        \textbf{Test ID:} Test-PS4\\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in, on profile page. \\
        \textbf{Input:} User navigates to help page. \\
        \textbf{Output:} The expected result is that a help page with FAQs and additional help information is displayed. \\
        \textbf{Test Case Derivation:} Ensure the help page is accessible and provides useful information. \\
        \textbf{How test will be performed:} Tester navigates to the help page and verifies the presence and accuracy of the information.
\end{enumerate}

\subsubsection{Settings Testing}
\label{sec:settings_testing}

The Settings Testing focuses on verifying user interactions related to modifying various settings, including accessibility, display, privacy, and profile settings. These tests ensure that users can customize their app experience according to their preferences and privacy requirements, enhancing usability and personalization.

\begin{enumerate}

  \item \textbf{Name:} {Modify Accessibility Settings} \label{itm:Test-S1}\\
        \textbf{Test ID:} Test-S1\\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in, viewing settings page. \\
        \textbf{Input:} User adjusts text size, enables/disables viewing of object names, or changes language. \\
        \textbf{Output:} The expected result is that accessibility settings apply as configured by the user. \\
        \textbf{Test Case Derivation:} Confirm that accessibility settings are configurable. \\
        \textbf{How test will be performed:} Tester changes each accessibility setting and verifies the changes apply.

  \item \textbf{Name:} {Adjust Display Settings} \label{itm:Test-S2}\\
        \textbf{Test ID:} Test-S2\\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in, viewing settings page. \\
        \textbf{Input:} User changes display settings such as light/dark mode or AR object visibility. \\
        \textbf{Output:} The expected result is that display settings reflect user preferences. \\
        \textbf{Test Case Derivation:} To ensure display settings are customizable by the user. \\
        \textbf{How test will be performed:} Tester modifies display settings and observes changes.

  \item \textbf{Name:} {Update Profile Settings} \label{itm:Test-s3}\\
        \textbf{Test ID:} Test-s3\\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} User logged in, viewing settings page. \\
        \textbf{Input:} User changes username, password, profile picture, or status. \\
        \textbf{Output:} The expected result is that profile settings are updated and saved. \\
        \textbf{Test Case Derivation:} Ensure users can update personal profile information. \\
        \textbf{How test will be performed:} Tester updates profile settings and verifies changes.

\end{enumerate}

\subsubsection{Interactions with User Inventory}

\begin{enumerate}

  \item \textbf{Name:} Delete Object from Inventory \label{itm:Test-IV1} \\
        \textbf{Test ID:} Test-IV1 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} App is open, tester is present on the Profile interface. Tester performs actions to open their Inventory. The Inventory is not empty. \\
        \textbf{Input:} Tester selects an object and chooses the delete option. \\
        \textbf{Output:} The selected object is removed from the inventory. \\
        \textbf{Test Case Derivation:} Users should have control over their inventory and be able to delete unwanted AR objects. \\
        \textbf{How test will be performed:} Tester will select an object in the inventory, delete it, and check if the AR object is successfully removed. \\

  \item \textbf{Name:} Add Object to Inventory \label{itm:Test-IV2} \\
        \textbf{Test ID:} Test-IV2 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} App is open, tester is present on the Profile interface Tester performs actions to open their Inventory. \\
        \textbf{Input:} Tester adds a new object to the inventory. \\
        \textbf{Output:} The new object appears in the inventory. \\
        \textbf{Test Case Derivation:} Users should be able to expand their inventory by adding objects. \\
        \textbf{How test will be performed:} Tester will add a new object to the inventory and confirm its appearance. The object can be added by AR object generation via prompt. \\

  \item \textbf{Name:} Application-Provided AR Objects in Inventory \label{itm:Test-IV3} \\
        \textbf{Test ID:} Test-IV3 \\
        \textbf{Control:} Automatic \\
        \textbf{Initial State:} App is installed and launched for the first time. Tester navigates to the Profile interface. \\
        \textbf{Input:} Tester opens the inventory. \\
        \textbf{Output:} Inventory contains the preloaded application-provided objects. \\
        \textbf{Test Case Derivation:} The inventory should always contain a set of default objects for user reference. \\
        \textbf{How test will be performed:} An automated test verifies that default objects are loaded and present in the user's inventory on app initialization. \\

  \item \textbf{Name:} Inventory Capacity for Personal Objects \label{itm:Test-IV4} \\
        \textbf{Test ID:} Test-IV4 \\
        \textbf{Control:} Automatic \\
        \textbf{Initial State:} Tester has 99 personal objects in inventory. \\
        \textbf{Input:} Tester attempts to add an additional object. \\
        \textbf{Output:} The object is successfully added, but adding another would be prevented. \\
        \textbf{Test Case Derivation:} Limiting personal objects prevents overuse of storage. \\
        \textbf{How test will be performed:} An automated test attempts to add objects beyond inventory limit to check if inventory maintains strict limit. \\

  \item \textbf{Name:} Personal Object Source Verification \label{itm:Test-IV5} \\
        \textbf{Test ID:} Test-IV5 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} Inventory contains personal objects generated or shared by users. \\
        \textbf{Input:} Tester opens the inventory and inspects object origins. \\
        \textbf{Output:} Each personal object is either user-generated or shared. \\
        \textbf{Test Case Derivation:} Ensures the integrity of inventory sources. \\
        \textbf{How test will be performed:} Tester inspects objects and verifies they meet origin requirements. \\

  \item \textbf{Name:} Total Object Count in Inventory \label{itm:Test-IV6} \\
        \textbf{Test ID:} Test-IV6 \\
        \textbf{Control:} Automatic \\
        \textbf{Initial State:} Inventory contains objects of varying types. \\
        \textbf{Input:} Tester views the total count of objects. \\
        \textbf{Output:} The app displays the correct total number of objects. \\
        \textbf{Test Case Derivation:} Provides users with an overview of their inventory. \\
        \textbf{How test will be performed:} Automated test calculates total object count and compares it to the displayed count. \\

  \item \textbf{Name:} Storage of 2D and 3D AR Objects \label{itm:Test-IV7} \\
        \textbf{Test ID:} Test-IV7 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} Inventory is empty or has objects. \\
        \textbf{Input:} Tester adds both 2D and 3D AR objects to their inventory. \\
        \textbf{Output:} Both 2D and 3D objects are correctly stored in inventory. \\
        \textbf{Test Case Derivation:} Inventory should be versatile in managing object types. \\
        \textbf{How test will be performed:} Tester can verify that both 2D and 3D objects are present in the inventory and is able to interact with them. \\

  \item \textbf{Name:} Add to Favourite Group \label{itm:Test-IV8} \\
        \textbf{Test ID:} Test-IV8 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} App is open, tester is viewing their Inventory. Inventory has objects. \\
        \textbf{Input:} Tester adds an object to the favourite group. \\
        \textbf{Output:} Object is marked as a favourite. \\
        \textbf{Test Case Derivation:} Users should highlight preferred objects for quick access. \\
        \textbf{How test will be performed:} Tester adds an object to favourites and verifies if the object is present under the favourite category. \\

  \item \textbf{Name:} Sort Objects \label{itm:Test-IV9} \\
        \textbf{Test ID:} Test-IV9 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} App is open, tester is viewing their Inventory. Inventory has objects with varied usage, favourites, and sizes. \\
        \textbf{Input:} Tester sorts objects by usage, favourites, or size. \\
        \textbf{Output:} Objects are sorted as per user selection. \\
        \textbf{Test Case Derivation:} Sorting aids in organizing objects for efficient use. \\
        \textbf{How test will be performed:} Tester selects sorting criteria and verifies that the results are indeed sorted, based on the selected criteria. \\

  \item \textbf{Name:} Continuous Rotation for 3D Objects \label{itm:Test-IV10} \\
        \textbf{Test ID:} Test-IV10 \\
        \textbf{Control:} Automatic \\
        \textbf{Initial State:} App is open, tester is viewing their Inventory. Inventory contains 3D objects. \\
        \textbf{Input:} Tester selects option to view a 3D AR object. \\
        \textbf{Output:} 3D objects are displayed in a continuous rotating state. \\
        \textbf{Test Case Derivation:} Rotation helps users fully examine 3D objects. \\
        \textbf{How test will be performed:} Automated test opens inventory and confirms rotation of 3D objects. \\

\end{enumerate}

\subsubsection{Maps Interface}

\begin{enumerate}

  \item \textbf{Name:} Map Location and Display of Overlays \label{itm:Test-MP1} \\
        \textbf{Test ID:} Test-MP1 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} App is open, tester navigates to the Map interface. \\
        \textbf{Input:} Tester is present on the Map interface and is viewing the complete map and check displayed information. \\
        \textbf{Output:}
        \begin{enumerate}
          \item User's current location is displayed on the map.
          \item Location markers appear for AR object clusters.
          \item Markers show the count of objects in each cluster.
        \end{enumerate}
        \textbf{Test Case Derivation:} Ensures that the map displays the user's location, object clusters, and relevant realm data accurately. \\
        \textbf{How Test Will Be Performed:}
        \begin{enumerate}
          \item Open the map and verify that the user's location is displayed correctly.
          \item Confirm that AR object clusters are marked and each marker displays an accurate count of objects.
          \item Check that all objects connected to the user are visible on the map.
        \end{enumerate}

  \item \textbf{Name:} Navigation and Directions on Map \label{itm:Test-MP2} \\
        \textbf{Test ID:} Test-MP2 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} Tester is viewing the map with visible AR object markers. \\
        \textbf{Input:} Select a marker and initiate navigation. Terminate navigation mid-route. \\
        \textbf{Output:}
        \begin{enumerate}
          \item Directions to the selected marker are provided.
          \item Navigation terminates when requested by the user.
        \end{enumerate}
        \textbf{Test Case Derivation:} Confirms that users can receive directions to selected markers and can end navigation if needed. \\
        \textbf{How Test Will Be Performed:}
        \begin{enumerate}
          \item Select a marker and confirm that the option to receive directions appears.
          \item Begin navigation and verify directions are correct.
          \item Terminate navigation and confirm that the system stops route guidance.
        \end{enumerate}

  \item \textbf{Name:} Clutter Management and Restricted Area Identification \label{itm:Test-MP3} \\
        \textbf{Test ID:} Test-MP3 \\
        \textbf{Control:} Automatic \\
        \textbf{Initial State:} Tester is viewing the map with a high density of objects. \\
        \textbf{Input:} Zoom in and out on the map and navigate toward restricted areas. \\
        \textbf{Output:}
        \begin{enumerate}
          \item Objects are grouped to reduce clutter on the map.
          \item Restricted areas are identified, and navigation to these areas is disallowed.
        \end{enumerate}
        \textbf{Test Case Derivation:} Ensures that map view remains clear through grouping and that restricted areas are indicated to prevent access. \\
        \textbf{How Test Will Be Performed:}
        \begin{enumerate}
          \item Zoom in and out to verify that objects are grouped or separated appropriately to avoid clutter.
          \item Attempt to navigate to a restricted area and confirm that the system prevents navigation.
        \end{enumerate}

\end{enumerate}

\subsubsection{Custom AR Object Generation}

\begin{enumerate}

  \item \textbf{Name:} Prompt Entry and Validation \label{itm:Test-POG1} \\
        \textbf{Test ID:} Test-POG1 \\
        \textbf{Control:} Automatic \\
        \textbf{Initial State:} App is open, tester is present on the prompt entry screen. \\
        \textbf{Input:} Enter prompts of various lengths, with and without profanity. \\
        \textbf{Output:}
        \begin{enumerate}
          \item Tester can successfully enter a prompt.
          \item The prompt is restricted to 200 characters.
          \item Character count is displayed in real-time as user types.
          \item Profanity is flagged and rejected.
        \end{enumerate}
        \textbf{Test Case Derivation:} Confirms that prompts adheres to length restrictions, real-time character count display, and profanity filtering. \\
        \textbf{How Test Will Be Performed:} Enter prompts within and exceeding 200 characters, observe character count display, and include some profanity to confirm filtering. \\

  \item \textbf{Name:} Object Type Selection and Confirmation \label{itm:Test-POG2} \\
        \textbf{Test ID:} Test-POG2 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} App is open, tester has entered a valid prompt and is ready to generate an object. \\
        \textbf{Input:} Select between 2D or 3D object type and confirm submission. \\
        \textbf{Output:}
        \begin{enumerate}
          \item The tester can select either 2D or 3D object type.
          \item System initiates AR object generation upon confirmation.
        \end{enumerate}
        \textbf{Test Case Derivation:} Ensures users can select object type before submission, and confirmation triggers generation. \\
        \textbf{How Test Will Be Performed:} Choose each object type and confirm prompt submission, tester observes the initiation of the object generation (2D or 3D). \\

  \item \textbf{Name:} AR Object Generation and Selection \label{itm:Test-POG3} \\
        \textbf{Test ID:} Test-POG3 \\
        \textbf{Control:} Automatic \\
        \textbf{Initial State:} App is open, tester has entered a valid prompt and confirmed initiation of object generation process. \\
        \textbf{Input:} Await object generation, then select one of the generated options. \\
        \textbf{Output:}
        \begin{enumerate}
          \item Multiple AR objects are generated based on the prompt.
          \item Tester can select a preferred object from the options provided.
        \end{enumerate}
        \textbf{Test Case Derivation:} Ensures the system generates multiple objects and allows user selection. \\
        \textbf{How Test Will Be Performed:} Submit a prompt, observe the generated objects, and select one to confirm selection functionality. \\

  \item \textbf{Name:} Add to Inventory \label{itm:Test-POG4} \\
        \textbf{Test ID:} Test-POG4 \\
        \textbf{Control:} Automatic \\
        \textbf{Initial State:} Tester has selected an AR object from the generated options. \\
        \textbf{Input:} Add the selected object to the personal inventory. \\
        \textbf{Output:} The chosen AR object is saved in the user's inventory. \\
        \textbf{Test Case Derivation:} Ensures that user selections can be stored in inventory for future access. \\
        \textbf{How Test Will Be Performed:} Add the object and confirm its presence in the inventory list. \\

  \item \textbf{Name:} Generated AR Object Preview \label{itm:Test-POG5} \\
        \textbf{Test ID:} Test-POG5 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} Tester is viewing a selected AR object in preview mode. \\
        \textbf{Input:} Rotate the AR object to inspect all sides. \\
        \textbf{Output:} The AR object rotates smoothly, allowing inspection from all angles. \\
        \textbf{Test Case Derivation:} Confirms that users can preview generated objects by rotating them. \\
        \textbf{How Test Will Be Performed:} Manually rotate the AR object to confirm smooth and complete rotation in preview mode. \\

\end{enumerate}

\subsubsection{Uploading Objects to Inventory}

\begin{enumerate}

  \item \textbf{Name:} Object Naming and Storage \label{itm:Test-OUI1} \\
        \textbf{Test ID:} Test-OUI1 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} Tester has finished editing and is ready to save the object. \\
        \textbf{Input:} Provide a name for the object, then save it to inventory with relevant metadata. \\
        \textbf{Output:}
        \begin{enumerate}
          \item Object name is stored, containing only ASCII characters.
          \item Creation date, time, user information, storage size, and type (2D or 3D) are stored with the object in the inventory.
        \end{enumerate}
        \textbf{Test Case Derivation:} Confirms that all necessary metadata is correctly assigned and stored along with the object. \\
        \textbf{How Test Will Be Performed:}
        \begin{enumerate}
          \item Enter a name containing only ASCII characters and confirm successful entry.
          \item Verify that all metadata, including date, time, user information, storage size, and type, is correctly saved.
          \item Access the object in inventory to confirm that metadata is retrievable and accurate.
        \end{enumerate}

  \item \textbf{Name:} Object Color Editing \label{itm:Test-OUI2} \\
        \textbf{Test ID:} Test-OUI2 \\
        \textbf{Control:} Manual \\
        \textbf{Initial State:} Object is open in the edit interface. \\
        \textbf{Input:} Select specific portions of the object and apply color changes. \\
        \textbf{Output:} Color changes are applied to selected portions of the object, and the final render reflects these edits accurately. \\
        \textbf{Test Case Derivation:} Verifies that users can apply color changes to specific parts of the object for customization. \\
        \textbf{How Test Will Be Performed:}
        \begin{enumerate}
          \item Select a portion of the object and change its color.
          \item Verify that the color change is applied only to the selected portion.
          \item Confirm that changes are saved and displayed correctly in the final render.
        \end{enumerate}

\end{enumerate}

\subsection{Tests for Nonfunctional Requirements}
This section focuses on test cases pertaining to the non-functional requirements.

\subsubsection{Usability Testing}

\begin{enumerate}

  \item \textbf{Name:} Validate Localization \label{itm:Test-QS-U1} \\
        \textbf{Test ID:} Test-QS-U1 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} App is open on settings page. \\
        \textbf{Input/Condition:} Language setting is changed to English, Mandarin Chinese, Hindi, Spanish, and French (The 5 most spoken languages in the world) in turn.  \\
        \textbf{Output/Result:} Text in the app correctly changes to the selected language, with understandable translations. \\
        \textbf{How test will be performed:} Tester navigates to settings menu, selects one of the languages to be tested, and verifies that text in the settings page, realm interface, and maps interface are all correctly displayed in the selected language

  \item \textbf{Name:} Validate User Intuitiveness and Satisfaction \label{itm:Test-QS-U2} \\
        \textbf{Test ID:} Test-QS-U2 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} App is open, and tester is logged in as a new user with no prior experience using the app. \\
        \textbf{Input/Condition:} Tester performs common workflows such as account setup, navigating between interfaces, creating AR objects, viewing and placing AR objects, and finding objects on the map, all without guidance or assistance  \\
        \textbf{Output/Result:} 80\% of testers complete each task and report that the app is easy and satisfying to use, and rate each workflow as highly intuitive.\\
        \textbf{How test will be performed:} A group of new users will perform specified workflows and complete a post-test \hyperref[sub:usability_survey]{survey} rating the intuitiveness and satisfaction of their experience. Quantitative results should show that most users rate the app as highly intuitive and satisfying to use.

\end{enumerate}

\subsubsection{Security Testing}

\begin{enumerate}

  \item
        \textbf{Name:} Encryption implementation message reading \label{itm:Test-QS-SC1} \\
        \textbf{Test ID:} Test-QS-SC1 \\
        \textbf{Type:} Manual \\
        \textbf{Initial State:} Encryption algorithm is complete, user has opened the app, and requests to the server are being monitored. \\
        \textbf{Input/Condition:} A request with sensitive information has been sent to the server. \\
        \textbf{Output/Result:} The contents of the information passed is not decipherable by reading the request but the server can decrypt the information to get the original message. \\
        \textbf{How test will be performed:} A tester will open the app and monitor requests made to the server. They will check to see if the information has been encrypted or not.

  \item
        \textbf{Name:} Encryption implementation algorithm check \label{itm:Test-QS-SC2} \\
        \textbf{Test ID:} Test-QS-SC2 \\
        \textbf{Type:} Static \\
        \textbf{Initial State:} Encryption algorithm is complete. \\
        \textbf{Input/Condition:} All code relating to the encryption algorithm will be sent to a static analyzer. \\
        \textbf{Output/Result:} The analyzer will show any vulnerabilities found within the algorithm \\
        \textbf{How test will be performed:} A tester will run a static analyzer that is tasked with finding code errors in the encryption algorithm implementation that could lead to an incorrect output by the system.

  \item
        \textbf{Name:} Verify identity before transmitting private data \label{itm:Test-QS-SC3} \\
        \textbf{Test ID:} Test-QS-SC3 \\
        \textbf{Type:} Manual \\
        \textbf{Initial State:} The app is ready for security review. \\
        \textbf{Input/Condition:} All sections of the code where a user's sensitive data is displayed is checked for a corresponding identity check. \\
        \textbf{Output/Result:} The sections all have a check to verify the user's identity before divulging the private data. \\
        \textbf{How test will be performed:} A tester will search through the code and find all locations where private data is being displayed. They will check to see if each of them are guarded by an identity verification check.

\end{enumerate}
\subsubsection{Availability Testing}

\begin{enumerate}

  \item \textbf{Name:} Validate Server Availability \label{itm:Test-QS-A1} \\
        \textbf{Test ID:} Test-QS-A1 \\
        \textbf{Type:} Non-Functional, Automated \\
        \textbf{Initial State:} Server is running, with monitoring tools actively tracking uptime. \\
        \textbf{Input/Condition:} Automated monitoring scripts track server uptime and downtime continuously over a one-week period \\
        \textbf{Output/Result:} Monitoring scripts log any downtime, with server uptime recorded at 99\% or higher over the test period. \\
        \textbf{How test will be performed:} Monitoring scripts will check server availability at regular intervals and log any downtime events, ensuring the server meets the 99\% availability criteria.


  \item \textbf{Name:} Validate User Feedback on Server Availability \label{itm:Test-QS-A2} \\
        \textbf{Test ID:} Test-QS-A2 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} Server is running, and a test group of users has been granted access to the app. \\
        \textbf{Input/Condition:} Over a one-week period, users in the test group access the app multiple times per day, as they normally would, at varying times. \\
        \textbf{Output/Result:} No user complaints about server unavailability during the test period. Users report no issues with app access. \\
        \textbf{How test will be performed:} Test group participants will be \hyperref[sub:usability_survey]{surveyed} at the end of the test period regarding any access issues they encountered. Any user-reported issues will be logged and reviewed to assess the server's availability from the user's perspective.

\end{enumerate}
\subsubsection{Maintainability Testing}

\begin{enumerate}

  \item \textbf{Name:} Validate API Error Message Clarity \label{itm:Test-DI-M1} \\
        \textbf{Test ID:} Test-DI-M1 \\
        \textbf{Type:} Non-Functional, Manual and Automated \\
        \textbf{Initial State:} System is running, with logging enabled for internal API calls. \\
        \textbf{Input/Condition:} Simulate the following types of system failures in internal APIs and observe the resulting error messages: database connection failure, invalid input data, service timeout. \\
        \textbf{Output/Result:} Error messages generated by the APIs clearly indicate the source and nature of the error in at least 90\% of cases, helping developers quickly identify issues. \\
        \textbf{How test will be performed:} Automated scripts will be used to simulate common errors and log the resulting API responses. The resulting error messages will be manually reviewed to be evaluated on detail (e.g., error type, location, and possible causes), and clarity (accurate indication of what is causing error). Success is achieved if 90\% of the messages help to identify the error source.


\end{enumerate}
\subsubsection{Compliance Testing}

\begin{enumerate}

  \item
        \textbf{Name:} Check Personal Information and Electronic
        Documents Act (PIPEDA) \cite{PIPEDA} compliance \label{itm:Test-CO1} \\
        \textbf{Test ID:} Test-CO1 \\
        \textbf{Type:} Manual \\
        \textbf{Initial State:} App is ready for compliance review. \\
        \textbf{Input/Condition:} The app in its current state is checked against PIPEDA for compliance. \\
        \textbf{Output/Result:} The app has been verified to comply with PIPEDA. \\
        \textbf{How test will be performed:} A tester will manually parse through PIPEDA and check off all the sections that the app comports with. The app should comply with all sections.

  \item
        \textbf{Name:} Tax records check going back six years \label{itm:Test-CO2} \\
        \textbf{Test ID:} Test-CO2 \\
        \textbf{Type:} Manual \\
        \textbf{Initial State:} The app is published on a app store. \\
        \textbf{Input/Condition:} Records are checked for purchases and ad-revenue made over the course of the project's lifetime. \\
        \textbf{Output/Result:} The records go back at least six years. \\
        \textbf{How test will be performed:} A tester will look at the history of all revenue generated through the app and make sure the records go back to the legally required time span of 6 years.

  \item
        \textbf{Name:} Check \textit{Google Play} developer policy \cite{GooglePlay} compliance \label{itm:Test-CO3} \\
        \textbf{Test ID:} Test-CO3 \\
        \textbf{Type:} Manual \\
        \textbf{Initial State:} App is ready for compliance review. \\
        \textbf{Input/Condition:} The app in its current state is checked against the \textit{Google Play} developer policy for compliance. \\
        \textbf{Output/Result:} The app has been verified to comply with the \textit{Google Play} developer policy. \\
        \textbf{How test will be performed:} A tester will manually parse through the \textit{Google Play} developer policy and mark down all the sections that the app comports with. The app should comply with all sections.

  \item
        \textbf{Name:} Check \textit{App Store} review guidelines \cite{AppStore} compliance \label{itm:Test-CO4} \\
        \textbf{Test ID:} Test-CO4 \\
        \textbf{Type:} Manual \\
        \textbf{Initial State:} App is ready for compliance review. \\
        \textbf{Input/Condition:} The app in its current state is checked against the \textit{App Store} review guidelines for compliance. \\
        \textbf{Output/Result:} The app has been verified to comply with the \textit{App Store} review guidelines. \\
        \textbf{How test will be performed:} A tester will manually parse through the \textit{App Store} review guidelines and mark down all the sections that the app comports with. The app should comply with all sections.

\end{enumerate}

\subsubsection{Reusability Testing}

\begin{enumerate}

  \item
        \textbf{Name:} Reusable components check \label{itm:Test-DI-R1} \\
        \textbf{Test ID:} Test-DI-R1 \\
        \textbf{Type:} Static \\
        \textbf{Initial State:} All code is available for analysis. \\
        \textbf{Input/Condition:} All code is sent to a static analyzer that has indicators for code duplication. \\
        \textbf{Output/Result:} The analysis will show metrics relating to the sections of code that have a high amount of duplication. \\
        \textbf{How test will be performed:} A tester will run the static analysis and look at the metrics to determine if an abstract component is warranted for sections of the code that have a lot of overlap. These sections could be simplified by having them all derive from a common component.

\end{enumerate}


\subsubsection{Portability Testing}

\begin{enumerate}

  \item \textbf{Name:} Validate Cross-Platform Compatibility \label{itm:Test-PT1} \\
        \textbf{Test ID:} Test-PT1 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} Application is built for both iOS and Android platforms. \\
        \textbf{Input/Condition:} Run the app on iOS and Android devices. \\
        \textbf{Output/Result:} The app is functional and displays correctly on both platforms. \\
        \textbf{How test will be performed:} Tester will install the app on both an iOS and an Android device, verifying consistent functionality and UI.

  \item \textbf{Name:} Common Codebase Validation \label{itm:Test-PT2} \\
        \textbf{Test ID:} Test-PT2 \\
        \textbf{Type:} Non-Functional, Code Review \\
        \textbf{Initial State:} The app's codebase is ready for review. \\
        \textbf{Input/Condition:} Inspect the codebase to ensure shared files are correctly configured with minimal platform-specific files. \\
        \textbf{Output/Result:} Codebase only differs in configuration files for platform-specific settings. \\
        \textbf{How test will be performed:} Developer will conduct a code walkthrough, focusing on configuration files to confirm minimal platform-specific variations.

  \item \textbf{Name:} Build Verification on iOS and Android \label{itm:Test-PT3} \\
        \textbf{Test ID:} Test-PT3 \\
        \textbf{Type:} Non-Functional, Automated \\
        \textbf{Initial State:} The cross-platform codebase is ready for automated build testing. \\
        \textbf{Input/Condition:} Initiate automated builds for both iOS and Android. \\
        \textbf{Output/Result:} Both builds succeed without errors. \\
        \textbf{How test will be performed:} An automated CI/CD pipeline will attempt to build the app for both platforms, confirming compatibility.

\end{enumerate}


\subsubsection{Safety Testing}

\begin{enumerate}

  \item \textbf{Name:} Distraction to Surroundings Assessment \label{itm:Test-SA1} \\
        \textbf{Test ID:} Test-SA1 \\
        \textbf{Type:} Non-Functional, Survey-Based \\
        \textbf{Initial State:} App is functional and ready for user testing. \\
        \textbf{Input/Condition:} Conduct a user survey after users engage with the app in a controlled environment. \\
        \textbf{Output/Result:} Survey results show that users do not find the app dangerously distracting them from their surroundings while using it. \\
        \textbf{How test will be performed:} A group of users will be observed using the app, followed by a survey asking them to rate their distraction levels from surrounding objects. Results will be analyzed to confirm minimal distraction.

  \item \textbf{Name:} No Bright Flashes or Loud Noises \label{itm:Test-SA2} \\
        \textbf{Test ID:} Test-SA2 \\
        \textbf{Type:} Non-Functional, Manual Inspection \\
        \textbf{Initial State:} The app is fully developed with all interfaces available for review. \\
        \textbf{Input/Condition:} Navigate through all screens and interactions within the app. \\
        \textbf{Output/Result:} No bright flashes or loud noises are present in any of the app interfaces. \\
        \textbf{How test will be performed:} Tester will manually explore the app, paying special attention to visual and audio elements, ensuring that no features could trigger discomfort or seizures in sensitive users.
\end{enumerate}

\subsubsection{Installation Testing}

\begin{enumerate}
  \item \textbf{Name:} Verify App Store Availability \label{itm:Test-I1} \\
        \textbf{Test ID:} Test-I1 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} App has been submitted and approved on both iOS and Android app stores. \\
        \textbf{Input/Condition:} Search for the app on the Apple App Store and Google Play Store. \\
        \textbf{Output/Result:} The app is available for download on both app stores. \\
        \textbf{How test will be performed:} Tester will verify the presence of the app by searching for it on the respective app stores and confirming it is listed and downloadable.

  \item \textbf{Name:} Simple Installation Process \label{itm:Test-I2} \\
        \textbf{Test ID:} Test-I2 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} App is available on both app stores. \\
        \textbf{Input/Condition:} Attempt to install the app on a device from both the Apple App Store and Google Play Store. \\
        \textbf{Output/Result:} The app installs directly without any additional steps or configurations. \\
        \textbf{How test will be performed:} Tester will initiate the installation from each app store, ensuring the app installs seamlessly without requiring extra configurations or settings adjustments.
\end{enumerate}

\subsubsection{Performance Requirements}

\begin{enumerate}

  \item \textbf{Name:} Map Rendering \label{itm:Test-QS-PE1} \\
        \textbf{Test ID:} Test-QS-PE1 \\
        \textbf{Type:} Non-Functional, Automatic, Dynamic \\
        \textbf{Initial State:} App is open, tester is present on any interface except for the Maps interface. \\
        \textbf{Input/Condition:} User performs actions to navigate to the Map interface. \\
        \textbf{Output/Result:} The map and its overlays are completely visible and can be interacted with. \\
        \textbf{How test will be performed:} Tester will navigate to the Maps interface. Once there, the load time for all overlays will be recorded and considered to introduce improvements in their loading and rendering. \\

  \item \textbf{Name:} Inventory Load \label{itm:Test-QS-PE2} \\
        \textbf{Test ID:} Test-QS-PE2 \\
        \textbf{Type:} Non-Functional, Automatic, Dynamic \\
        \textbf{Initial State:} App is open, and the tester is present on their profile page. \\
        \textbf{Input/Condition:} User selects the option to view their entire Inventory. \\
        \textbf{Output/Result:} The Inventory loads completely and can be interacted with within 1-10 seconds depending on the number of objects present in the Inventory. \\
        \textbf{How test will be performed:} Tester will access the Inventory section and the application will record the load time such that the time is recorded until the user is able to interact with the objects visible. Then, the tester can observe the recorded load times and verify if the times are below the maximum threshold (10 seconds). \\

  \item \textbf{Name:} AR Object Generation \label{itm:Test-QS-PE4} \\
        \textbf{Test ID:} Test-QS-PE4 \\
        \textbf{Type:} Non-Functional, Automatic \\
        \textbf{Initial State:} App is open, tester is present on object generation interface and has entered a \textit{valid} prompt to begin AR object generation. \\
        \textbf{Input/Condition:} Tester initiates the generation of an AR object. \\
        \textbf{Output/Result:} The AR object is fully generated and visible. \\
        \textbf{How test will be performed:} Tester will initiate AR object generation and start a timer. The timer will be stopped once the AR object is fully generated and visible. The time taken is recorded to verify the process takes at most 30 seconds. \\

  \item \textbf{Name:} AR Object Fallback Mode \label{itm:Test-QS-PE5} \\
        \textbf{Test ID:} Test-QS-PE5 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} App is open on a low-performance device. \\
        \textbf{Input/Condition:} Tester attempts to view AR objects within the app. \\
        \textbf{Output/Result:} The app renders AR objects with minimal lag or provides a fallback mode (low-resolution objects) for accessibility. \\
        \textbf{How test will be performed:} Tester will use a low-performance device to attempt rendering AR objects. Performance will be observed to confirm the app enables a fallback mode for compatibility such as lower resolution for AR objects and limited functionality in terms of app features. \\

\end{enumerate}

\subsubsection{Reliability Requirements}

\begin{enumerate}

  \item \textbf{Name:} Database Failure/Corruption \label{itm:Test-QS-RE1} \\
        \textbf{Test ID:} Test-QS-RE1 \\
        \textbf{Type:} Non-Functional, Dynamic, Automatic \\
        \textbf{Initial State:} The app is running with a stable connection to the primary database, and all user data is accessible without issues. (No failure or corruption has occurred in the database) \\
        \textbf{Input:} Inject random data or errors into the test database to trigger failure. \\
        \textbf{Output:}
        \begin{enumerate}
          \item Database recovers automatically or through a set of recovery steps.
          \item If there is user data loss, only \textbf{2\%} of user data will be lost after the recovery.
          \item System returns to normal operation, allowing all users to access their data without issues.
        \end{enumerate}
        \textbf{How Test Will Be Performed:}
        \begin{enumerate}
          \item Set up a testing environment where the database can be backed up and forcefully corrupted.
          \item Initiate a database corruption/failure.
          \item Ensure that the system detects and logs the failure and attempts recovery.
          \item After the recovery process is finished, review the data with a backed-up copy for multiple test user accounts to confirm that large amounts of user data have not been erased.
          \item Compute the data loss percent to ensure it does not exceed the stated limit.
        \end{enumerate}

\end{enumerate}

\subsubsection{Distribution Requirements}

\begin{enumerate}

  \item \textbf{Name:} Device Compatibility \label{itm:Test-DI-D1} \\
        \textbf{Test ID:} Test-DI-D1 \\
        \textbf{Type:} Non-Functional, Automatic \\
        \textbf{Initial State:} The app is not yet installed on test devices. The test devices include mobile devices running iOS 16.0+ and Android 12+ and even older Android and iOS versions. \\
        \textbf{Input/Condition:} Attempt to download and install the app on the user device. \\
        \textbf{Output/Result:}
        \begin{enumerate}
          \item The app installs successfully on devices running iOS 16.0+ and Android 12+.
          \item The app functions as expected post-installation on the device.
        \end{enumerate}
        \textbf{How test will be performed:} Install the app on a device, app checks if the device's OS version satisfies the requirements. \\

  \item \textbf{Name:} Regional Availability \label{itm:Test-DI-D2} \\
        \textbf{Test ID:} Test-DI-D2 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} The app is available in the app store. \\
        \textbf{Input/Condition:} Attempt to access and download the app from app stores within Canada and the USA. \\
        \textbf{Output/Result:} The app is accessible and can be downloaded by users in both Canada and the USA.
        \textbf{How test will be performed:} Using devices connected to networks in Canada and the USA, check that the app is accessible, downloadable, and installable from each app store. \\

  \item \textbf{Name:} Recommended Age Requirement Display \label{itm:Test-DI-D3} \\
        \textbf{Test ID:} Test-DI-D3 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} The app is available in the app store, ready to be viewed by users. \\
        \textbf{Input/Condition:} Open the app store listing for the app. \\
        \textbf{Output/Result:} The app store listing clearly shows a recommended age requirement of 16+.
        \textbf{How test will be performed:} View the app's store page on various devices and confirm the presence of the age recommendation. \\

  \item \textbf{Name:} User Data Storage in North America \label{itm:Test-DI-D4} \\
        \textbf{Test ID:} Test-DI-D4 \\
        \textbf{Type:} Non-Functional, Manual \\
        \textbf{Initial State:} User data is being created and saved through app usage. \\
        \textbf{Input/Condition:} Review server locations where user data is stored. \\
        \textbf{Output/Result:} All user data is stored within North America.
        \textbf{How test will be performed:} Verify if app servers used for user data storage and processing are located within North American. \\

\end{enumerate}

\subsection{Traceability Between Test Cases and Requirements}

\begin{table}[htpb!]
  \centering
  \begin{tabular}{|l|p{8cm}|p{3cm}|}
    \hline
    \textbf{Test-ID}                      & \textbf{Test Name}                                 & \textbf{Requirements} \\
    \hline
    \hyperref[itm:Test-RI1]{Test-RI1}     & Validate AR Object Perspective Adjustment          & RI-FR1.1              \\
    \hline
    \hyperref[itm:Test-RI2]{Test-RI2}     & Validate AR Object Clutter Management              & RI-FR1.2              \\
    \hline
    \hyperref[itm:Test-RI3]{Test-RI3}     & Validate AR Object Placement Accuracy              & RI-FR1.2              \\
    \hline
    \hyperref[itm:Test-RI6]{Test-RI6}     & Validate Object Placement Workflow Control         & RI-FR3                \\
    \hline
    \hyperref[itm:Test-RI8]{Test-RI8}     & Validate Nearby Tour Indication                    & RI-FR5                \\
    \hline
    \hyperref[itm:Test-RI9]{Test-RI9}     & Validate Hazard Warning                            & RI-FR6                \\
    \hline
    \hyperref[itm:Test-RI10]{Test-RI10}   & Validate Offline Mode for Interactive Components   & RI-FR7                \\
    \hline
    \hyperref[itm:Test-OP1]{Test-OP1}     & Validate Object Selection Stage                    & OP-FR2.1              \\
    \hline
    \hyperref[itm:Test-OP3]{Test-OP3}     & Validate Object Placement Stage                    & OP-FR2.3              \\
    \hline
    \hyperref[itm:Test-OP4]{Test-OP4}     & Validate Object Instance Storage                   & OP-FR1                \\
    \hline
    \hyperref[itm:Test-OP5]{Test-OP5}     & Validate Area Based Placement Limit                & OP-FR3.1              \\
    \hline
    \hyperref[itm:Test-OP6]{Test-OP6}     & Validate Time Based Placement Limit                & OP-FR3.2              \\
    \hline
    \hyperref[itm:Test-OP7]{Test-OP7}     & Validate Automated Retry for Failed Object Storage & OP-FR1                \\
    \hline
    \hyperref[itm:Test-DB1]{Test-DB1}     & Validate Periodic Database Backup                  & DB-FR1                \\
    \hline
    \hyperref[itm:Test-DB2]{Test-DB2}     & Validate Database Encryption                       & DB-FR2                \\
    \hline
    \hyperref[itm:Test-QS-U1]{Test-QS-U1} & Validate Localization                              & QS-U1                 \\
    \hline
    \hyperref[itm:Test-QS-U2]{Test-QS-U2} & Validate User Intuitiveness and Satisfaction       & QS-U2                 \\
    \hline
    \hyperref[itm:Test-QS-A1]{Test-QS-A1} & Automated Server Availability Monitoring           & QS-A1                 \\
    \hline
    \hyperref[itm:Test-QS-A2]{Test-QS-A2} & User Feedback on Server Availability               & QS-A1                 \\
    \hline
    \hyperref[itm:Test-DI-M1]{Test-DI-M1} & Validate API Error Message Clarity                 & DI-M1                 \\
    \hline
  \end{tabular}
  \caption{Mapping of Tests to Requirements (I)}
  \label{tab:test_requirements1}
\end{table}

\begin{table}[htpb!]
  \centering
  \begin{tabular}{|l|p{8cm}|p{3cm}|}
    \hline
    \hyperref[itm:Test-PS1]{Test-PS1} & Validate User Authentication          & PS-FR1 \\
    \hline
    \hyperref[itm:Test-PS2]{Test-PS2} & Password Change Functionality         & PS-FR3 \\
    \hline
    \hyperref[itm:Test-PS3]{Test-PS3} & View Profile Information              & PS-FR4 \\
    \hline
    \hyperref[itm:Test-PS4]{Test-PS4} & Access Help Page                      & PS-FR6 \\
    \hline
    \hyperref[itm:Test-S1]{Test-S1}   & Modify Accessibility Settings         & S-FR1  \\
    \hline
    \hyperref[itm:Test-S2]{Test-S2}   & Adjust Display Settings               & S-FR2  \\
    \hline
    \hyperref[itm:Test-s3]{Test-s3}   & Update Profile Settings               & S-FR4  \\
    \hline
    \hyperref[itm:Test-PT1]{Test-PT1} & Validate Cross-Platform Compatibility & DI-P1  \\
    \hline
    \hyperref[itm:Test-PT2]{Test-PT2} & Common Codebase Validation            & DI-P2  \\
    \hline
    \hyperref[itm:Test-PT3]{Test-PT3} & Build Verification on iOS and Android & DI-P1  \\
    \hline
    \hyperref[itm:Test-SA1]{Test-SA1} & Distraction Level Assessment          & QS-SA1 \\
    \hline
    \hyperref[itm:Test-SA2]{Test-SA2} & No Bright Flashes or Loud Noises      & QS-SA2 \\
    \hline
    \hyperref[itm:Test-I1]{Test-I1}   & Verify App Store Availability         & DI-I1  \\
    \hline
    \hyperref[itm:Test-I2]{Test-I2}   & Simple Installation Process           & DI-I2  \\
    \hline
  \end{tabular}
  \caption{Mapping of Tests to Requirements (II)}
  \label{tab:test_requirements2}
\end{table}

\begin{table}[htpb!]
  \centering
  \begin{tabular}{|l|p{8cm}|p{3cm}|}
    \hline
    \hyperref[itm:Test-TM1]{Test-TM1} & \textit{Organization Users} can access tour management screen                                                         & TM-FR1   \\
    \hline
    \hyperref[itm:Test-TM2]{Test-TM2} & \textit{General Users} can NOT access the tour management screen                                                      & TM-FR1   \\
    \hline
    \hyperref[itm:Test-TM3]{Test-TM3} & \textit{Organization Users} can create a customized tour                                                              & TM-FR4   \\
    \hline
    \hyperref[itm:Test-TM4]{Test-TM4} & \textit{Organization Users} can create a tour as a draft                                                              & TM-FR2   \\
    \hline
    \hyperref[itm:Test-TM5]{Test-TM5} & \textit{Organization Users} can create a tour and directly publish it                                                 & TM-FR3   \\
    \hline
    \hyperref[itm:Test-TM6]{Test-TM6} & \textit{Organization Users} can publish a draft tour                                                                  & TM-FR3   \\
    \hline
    \hyperref[itm:Test-TM7]{Test-TM7} & \textit{Organization Users} can preview one of their tours                                                            & TM-FR5   \\
    \hline
    \hyperref[itm:Test-TM8]{Test-TM8} & \textit{Organization Users} can edit one of their tours                                                               & TM-FR6   \\
    \hline
    \hyperref[itm:Test-TR1]{Test-TR1} & \textit{General Users} can access the touring screen                                                                  & TR-FR1   \\
    \hline
    \hyperref[itm:Test-TR2]{Test-TR2} & \textit{Organization Users} can NOT access the touring screen                                                         & TR-FR1   \\
    \hline
    \hyperref[itm:Test-TR3]{Test-TR3} & \textit{General Users} can preview a tour                                                                             & TR-FR3   \\
    \hline
    \hyperref[itm:Test-TR4]{Test-TR4} & \textit{General Users} can find a tour through the tour list interface                                                & TR-FR2.1 \\
    \hline
    \hyperref[itm:Test-TR5]{Test-TR5} & \textit{General Users} can find a tour through a push notification when in proximity to a tour area in the real-world & TR-FR2.2 \\
    \hline
  \end{tabular}
  \caption{Mapping of Tests to Requirements (III)}
  \label{tab:test_requirements3}
\end{table}

\begin{table}[htpb!]
  \centering
  \begin{tabular}{|l|p{8cm}|p{3cm}|}
    \hline
    \hyperref[itm:Test-TR6]{Test-TR6}       & \textit{General Users} can find a tour through a QR code                                  & TR-FR2.3       \\
    \hline
    \hyperref[itm:Test-TR7]{Test-TR7}       & \textit{General Users} can switch between the map and AR view in a tour                   & TR-FR4         \\
    \hline
    \hyperref[itm:Test-TR8]{Test-TR8}       & \textit{General Users} can see the map tour view                                          & TR-FR4.1       \\
    \hline
    \hyperref[itm:Test-TR9]{Test-TR9}       & \textit{General Users} can see the AR tour view                                           & TR-FR4.2       \\
    \hline
    \hyperref[itm:Test-QS-SC1]{Test-QS-SC1} & Encryption implementation message reading                                                 & QS-SC1         \\
    \hline
    \hyperref[itm:Test-QS-SC2]{Test-QS-SC2} & Encryption implementation algorithm check                                                 & QS-SC1         \\
    \hline
    \hyperref[itm:Test-QS-SC3]{Test-QS-SC3} & Verify identity before transmitting private data                                          & QS-SC2         \\
    \hline
    \hyperref[itm:Test-CO1]{Test-CO1}       & Check Personal Information and Electronic Documents Act (PIPEDA) \cite{PIPEDA} compliance & CO1            \\
    \hline
    \hyperref[itm:Test-CO2]{Test-CO2}       & Tax records check going back six years                                                    & CO2            \\
    \hline
    \hyperref[itm:Test-CO3]{Test-CO3}       & Check \textit{Google Play} developer policy \cite{GooglePlay} compliance                  & CO3            \\
    \hline
    \hyperref[itm:Test-CO4]{Test-CO4}       & Check \textit{App Store} review guidelines \cite{AppStore} compliance                     & CO4            \\
    \hline
    \hyperref[itm:Test-DI-R1]{Test-DI-R1}   & Reusable components check                                                                 & DI-R1          \\
    \hline
    \hyperref[itm:Test-OS1]{Test-OS1}       & Surroundings Scan                                                                         & OS-FR1, OS-FR4 \\
    \hline
    \hyperref[itm:Test-OS2]{Test-OS2}       & Object Type Selection                                                                     & OS-FR2         \\
    \hline
    \hyperref[itm:Test-OS3]{Test-OS3}       & Real-Time Render Display                                                                  & OS-FR3         \\
    \hline
    \hyperref[itm:Test-IV1]{Test-IV1}       & Delete Object from Inventory                                                              & IV-FR1         \\
    \hline
    \hyperref[itm:Test-IV2]{Test-IV2}       & Add Object to Inventory                                                                   & IV-FR2         \\
    \hline
    \hyperref[itm:Test-IV3]{Test-IV3}       & Application-Provided AR Objects in Inventory                                              & IV-FR3         \\
    \hline
    \hyperref[itm:Test-IV4]{Test-IV4}       & Inventory Capacity for Personal Objects                                                   & IV-FR4         \\
    \hline
    \hyperref[itm:Test-IV5]{Test-IV5}       & Personal Object Source Verification                                                       & IV-FR5         \\
    \hline
  \end{tabular}
  \caption{Mapping of Tests to Requirements (IV)}
  \label{tab:test_requirements4}
\end{table}

\begin{table}[htpb!]
  \centering
  \begin{tabular}{|l|p{8cm}|p{3cm}|}
    \hline
    \hyperref[itm:Test-IV6]{Test-IV6}   & Total Object Count in Inventory                       & IV-FR6                                                          \\
    \hline
    \hyperref[itm:Test-IV7]{Test-IV7}   & Storage of 2D and 3D AR Objects                       & IV-FR7                                                          \\
    \hline
    \hyperref[itm:Test-IV8]{Test-IV8}   & Add to Favourite Group                                & IV-FR8                                                          \\
    \hline
    \hyperref[itm:Test-IV9]{Test-IV9}   & Sort Objects                                          & IV-FR9                                                          \\
    \hline
    \hyperref[itm:Test-IV10]{Test-IV10} & Continuous Rotation for 3D Objects                    & IV-FR10                                                         \\
    \hline
    \hyperref[itm:Test-MP1]{Test-MP1}   & Map Location and Display of Overlays                  & MP-FR1, MP-FR2, MP-FR3, MP-FR4, MP-FR5                          \\
    \hline
    \hyperref[itm:Test-MP2]{Test-MP2}   & Navigation and Directions on Map                      & MP-FR6, MP-FR7, MP-FR9                                          \\
    \hline
    \hyperref[itm:Test-MP3]{Test-MP3}   & Clutter Management and Restricted Area Identification & MP-FR8, MP-FR10                                                 \\
    \hline
    \hyperref[itm:Test-POG1]{Test-POG1} & Prompt Entry and Validation                           & POG-FR1, POG-FR2, POG-FR3, POG-FR4                              \\
    \hline
    \hyperref[itm:Test-POG2]{Test-POG2} & Object Type Selection and Confirmation                & POG-FR5, POG-FR6                                                \\
    \hline
    \hyperref[itm:Test-POG3]{Test-POG3} & AR Object Generation and Selection                    & POG-FR7, POG-FR8                                                \\
    \hline
    \hyperref[itm:Test-POG4]{Test-POG4} & Add to Inventory                                      & POG-FR9                                                         \\
    \hline
    \hyperref[itm:Test-POG5]{Test-POG5} & Generated AR Object Preview                           & POG-FR10                                                        \\
    \hline
    \hyperref[itm:Test-OUI1]{Test-OUI1} & Object Naming and Storage                             & OUI-FR5 OUI-FR6, OUI-FR7, OUI-FR8, OUI-FR9, OUI-FR10, OUI-FR11, \\
    \hline
    \hyperref[itm:Test-OUI2]{Test-OUI2} & Object Color Editing                                  & OUI-FR12                                                        \\
    \hline
  \end{tabular}
  \caption{Mapping of Tests to Requirements (V)}
  \label{tab:test_requirements5}
\end{table}

\begin{table}[htpb!]
  \centering
  \begin{tabular}{|l|p{8cm}|p{3cm}|}
    \hline
    \hyperref[itm:Test-QS-PE1]{Test-QS-PE1} & Map Rendering                       & QS-PE1 \\
    \hline
    \hyperref[itm:Test-QS-PE2]{Test-QS-PE2} & Inventory Load                      & QS-PE2 \\
    \hline
    \hyperref[itm:Test-QS-PE4]{Test-QS-PE4} & AR Object Generation                & QS-PE4 \\
    \hline
    \hyperref[itm:Test-QS-PE5]{Test-QS-PE5} & AR Object Fallback Mode             & QS-PE5 \\
    \hline
    \hyperref[itm:Test-QS-RE1]{Test-QS-RE1} & Database Failure/Corruption         & QS-RE1 \\
    \hline
    \hyperref[itm:Test-DI-D1]{Test-DI-D1}   & Device Compatibility                & DI-D1  \\
    \hline
    \hyperref[itm:Test-DI-D2]{Test-DI-D2}   & Regional Availability               & DI-D2  \\
    \hline
    \hyperref[itm:Test-DI-D3]{Test-DI-D3}   & Recommended Age Requirement Display & DI-D3  \\
    \hline
    \hyperref[itm:Test-DI-D4]{Test-DI-D4}   & User Data Storage in North America  & DI-D4  \\
    \hline
  \end{tabular}
  \caption{Mapping of Tests to Requirements (VI)}
  \label{tab:test_requirements6}
\end{table}

\pagebreak


\section{Unit Test Description}

This section contains descriptions of the unit tests derived from the MIS.

\subsection{Settings Module Testing}
\begin{enumerate}
  \item \textbf{Name:} Key Validation \label{itm:Test-SM1} \\
        \textbf{Test ID:} Test-SM1 \\
        \textbf{Type:} Functional, Automated \\
        \textbf{Initial State:} Settings module is initialized \\
        \textbf{Input/Condition:} One key that is a valid settings key, and another that is not  \\
        \textbf{Output/Result:} The function should return true for the valid key, and false for the invalid key  \\
        \textbf{How test will be performed:} The \textbf{ValidateKey} method on the settings module will be called with the inputs

  \item \textbf{Name:} Ensure Valid Profile Details \label{itm:Test-SM2} \\
        \textbf{Test ID:} Test-SM2 \\
        \textbf{Type:} Functional, Automated \\
        \textbf{Initial State:} Settings module is initialized \\
        \textbf{Input/Condition:} A valid user settings object  \\
        \textbf{Output/Result:} The function should return an object matching the schema of the valid user settings object  \\
        \textbf{How test will be performed:} The \textbf{FetchProfileDetails} method on the settings module will be called with the inputs

\end{enumerate}

\subsection{Help Module Testing}
\begin{enumerate}
  \item \textbf{Name:} String Search \label{itm:Test-HM1} \\
        \textbf{Test ID:} Test-HM1 \\
        \textbf{Type:} Functional, Automated \\
        \textbf{Initial State:} Help module is initialized \\
        \textbf{Input/Condition:} Partial and full keywords matching help items  \\
        \textbf{Output/Result:} The search result outputs should match the precomputed expected search results for the provided search terms  \\
        \textbf{How test will be performed:} The \textbf{SearchHelp} method on the help module will be called with the inputs

\end{enumerate}


\subsection{Collision Detection Module Testing}
\begin{enumerate}
  \item \textbf{Name:} Detect Collision \label{itm:Test-CD1} \\
        \textbf{Test ID:} Test-CD1 \\
        \textbf{Type:} Functional, Automated \\
        \textbf{Initial State:} Collision detection module is initialized \\
        \textbf{Input/Condition:} Mock AR tracking data and device accelerometer data representing hazardous and non-hazardous scenarios \\
        \textbf{Output/Result:} The function should output true for potential collisions, and false otherwise \\
        \textbf{How test will be performed:} The \textbf{DetectCollision} method on the collision detection module will be called with the inputs

\end{enumerate}

\subsection{Tour Proximity Module Testing}

\begin{enumerate}
  \item \textbf{Name:} Detect Nearby Tour \label{itm:Test-TP1} \\
        \textbf{Test ID:} Test-TP1 \\
        \textbf{Type:} Functional, Automated \\
        \textbf{Initial State:} Tour proximity module is initialized \\
        \textbf{Input/Condition:} Mock GPS data representing device, and tour positions \\
        \textbf{Output/Result:} The function should output a list containing all tours within a certain distance, and excluding the rest \\
        \textbf{How test will be performed:} The \textbf{DetectNearbyTours} method on the tour proximity module will be called with the inputs
        The scope of the unit testing is limited to helper functions present in scripts used by Unity objects. The unit tests will be written in C\# and will be executed using the Unity Test Framework. The tests will be written to ensure that the helper functions are working as expected and are free of bugs.

\end{enumerate}

\subsection{Local Database Manager}

\begin{enumerate}

  \item \textbf{Name:} fetchData \label{itm:Test-LDM-FD} \\
        \textbf{Test ID:} Test-LDM-FD \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A string Query to access database entries that need to be fetched from local database \\
        \textbf{Output/Result:} The data expected by the caller (could be binary, string, integer, float, etc.) \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to fetch data from the local database. \\
        \textbf{How test will be performed:} This function will be called and the tester will check if data is retrieved with no errors. The tester must also verify if the data retrieved from the database matches the expected data. \\

  \item \textbf{Name:} saveData \label{itm:Test-LDM-SD} \\
        \textbf{Test ID:} Test-LDM-SD \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A key to access the data in the future and the data that needs to be added to the database. \\
        \textbf{Output/Result:} No exceptions are thrown and the data can be observed in the local database through the dev environment. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to save data to the local database. \\
        \textbf{How test will be performed:} The function will be used by the tester to save a new data entry in the local database. If no errors are shown, the test has passed otherwise the function must be corrected to prevent any errors. \\

  \item \textbf{Name:} updateData \label{itm:Test-LDM-UD} \\
        \textbf{Test ID:} Test-LDM-UD \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} Data entries must exist in the local database \\
        \textbf{Input/Condition:} A key referring to the data needed to be updated and the new content that replaces the existing data entry in the local database. \\
        \textbf{Output/Result:} No output is expected and the new content can be seen under the key used to update the entry in the local database. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to update data in the local database. \\
        \textbf{How test will be performed:} The tester will call the function with the key and new content and after the function is called, they can observe whether the data under the key passed into the function matches the new content they wanted in the database. \\

  \item \textbf{Name:} deleteData \label{itm:Test-LDM-DD} \\
        \textbf{Test ID:} Test-LDM-DD \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} Data entries must exist in the local database \\
        \textbf{Input/Condition:} Key used to access the data that needs to be deleted \\
        \textbf{Output/Result:} No output is expected and the data entry should not exist in the local database. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to delete data from the local database. \\
        \textbf{How test will be performed:} The function will be called with the appropriate key and the tester will then check if the data entry corresponding to the input key still exists. If it does not, the function has passed the test. \\

  \item \textbf{Name:} syncWithServer \label{itm:Test-LDM-SWS} \\
        \textbf{Test ID:} Test-LDM-SWS \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} No input is needed \\
        \textbf{Output/Result:} No output is expected. The data present in the local database is up to date and matches with the server database. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to sync the local database with the server database. \\
        \textbf{How test will be performed:} The tester will call the function and check if all the entries between the local database and the server database match (This could be done using a script to compare all entries in the database). \\

  \item \textbf{Name:} isCacheStale \label{itm:Test-LDM-ICS} \\
        \textbf{Test ID:} Test-LDM-ICS \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} No input is needed \\
        \textbf{Output/Result:} Output True or False based on whether the local database is outdated compared to the server database. \\
        \textbf{How test will be performed:} The tester will call the function on an outdated local database and check if the function correctly returns True. The function will also be executed on an up-to-date local database with an expected output of False. \\

\end{enumerate}

\subsection{Server Database Manager}

\begin{enumerate}

  \item \textbf{Name:} fetchData \label{itm:Test-SDM-FD} \\
        \textbf{Test ID:} Test-SDM-FD \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A string Query to access database entries that need to be fetched from server database \\
        \textbf{Output/Result:} The data expected by the caller (could be binary, string, integer, float, etc.) \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to fetch data from the server database. \\
        \textbf{How test will be performed:} This function will be called and the tester will check if data is retrieved from the server database with no errors. The tester must also verify if the data retrieved from the database matches the expected data. \\

  \item \textbf{Name:} saveData \label{itm:Test-SDM-SD} \\
        \textbf{Test ID:} Test-SDM-SD \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A key to access the data in the future and the data that needs to be added to the database. \\
        \textbf{Output/Result:} No exceptions are thrown and the data can be observed in the server database through the dev environment. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to save data to the server database. \\
        \textbf{How test will be performed:} The function will be used by the tester to save a new data entry in the server database. If no errors are shown, the test has passed otherwise the function must be corrected to prevent any errors. \\

  \item \textbf{Name:} updateData \label{itm:Test-SDM-UD} \\
        \textbf{Test ID:} Test-SDM-UD \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} Data entries must exist in the server database \\
        \textbf{Input/Condition:} A key referring to the data needed to be updated and the new content that replaces the existing data entry in the server database. \\
        \textbf{Output/Result:} No output is expected and the new content can be seen under the key used to update the entry in the server database. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to update data in the server database. \\
        \textbf{How test will be performed:} The tester will call the function with the key and new content and after the function is called, they can observe whether the data under the key passed into the function matches the new content they wanted in the database. \\

  \item \textbf{Name:} deleteData \label{itm:Test-SDM-DD} \\
        \textbf{Test ID:} Test-SDM-DD \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} Data entries must exist in the server database \\
        \textbf{Input/Condition:} Key used to access the data that needs to be deleted \\
        \textbf{Output/Result:} No output is expected and the data entry should not exist in the server database. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to delete data from the server database. \\
        \textbf{How test will be performed:} The function will be called with the appropriate key and the tester will then check if the data entry corresponding to the input key still exists. If it does not, the function has passed the test. \\

  \item \textbf{Name:} syncWithLocal \label{itm:Test-SDM-SWL} \\
        \textbf{Test ID:} Test-SDM-SWL \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A list of key-to-data entries that are present in the local database and not the server one. \\
        \textbf{Output/Result:} The data present in the server database matches with the local database. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to sync the server database with the local database. \\
        \textbf{How test will be performed:} The tester will call the function with the data not present in the local database, and check if all the entries between the local database and the server database match (This could be done using a script to compare all entries in the database). \\

  \item \textbf{Name:} logSyncOperation \label{itm:Test-SDM-LSO} \\
        \textbf{Test ID:} Test-SDM-LSO \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} A sync operation is executed between the local and server database \\
        \textbf{Input/Condition:} A boolean status that can be retrieved from the module's \texttt{status} flag \\
        \textbf{Output/Result:} No output is expected and the log should be written to the application's log terminal. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to log sync operations between the local and server databases. \\
        \textbf{How test will be performed:} The tester will call the function with the appropriate status and check if the log is written to the application's log terminal. \\

\end{enumerate}

\subsection{REST API Communication}

\begin{enumerate}

  \item \textbf{Name:} sendRequest \label{itm:Test-RAC-SR} \\
        \textbf{Test ID:} Test-RAC-SR \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A string representing an endpoint, a string representing the HTTP method (GET, POST, PUT, DELETE) and a string that has the request body.  \\
        \textbf{Output/Result:} The response from the server. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to send a request to the API server. \\
        \textbf{How test will be performed:} The tester will call the function with the appropriate parameters and check if the response from the server is as expected. \\

  \item \textbf{Name:} parseResponse \label{itm:Test-RAC-PR} \\
        \textbf{Test ID:} Test-RAC-PR \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} An HTTP request must be correctly retrieved after requesting. \\
        \textbf{Input/Condition:} A raw HTTP response. \\
        \textbf{Output/Result:} Outputs the JSONified HTTP response. \\
        \textbf{Test Case Derivation:} To check if the Raw Response from the HTTP request can be converted into a JSON object that is easier to work with. \\
        \textbf{How test will be performed:} The tester will call the function with the raw HTTP response and check if the JSON object is returned. \\

  \item \textbf{Name:} setHeaders \label{itm:Test-RAC-SH} \\
        \textbf{Test ID:} Test-RAC-SH \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A string representing the header used for subsequent HTTP requests. \\
        \textbf{Output/Result:} No output is expected. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to set headers for the HTTP request. \\
        \textbf{How test will be performed:} The tester will call the function with the appropriate header and check if the header is set for the subsequent HTTP requests. \\

  \item \textbf{Name:} handleAuthentication \label{itm:Test-RAC-HA} \\
        \textbf{Test ID:} Test-RAC-HA \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A string token representing the authentication token. \\
        \textbf{Output/Result:} No output is expected \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to handle authentication for the HTTP request. \\
        \textbf{How test will be performed:}

  \item \textbf{Name:} checkServerStatus \label{itm:Test-RAC-CSS} \\
        \textbf{Test ID:} Test-RAC-CSS \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A boolean status that can be retrieved from the module's \texttt{status} flag \\
        \textbf{Output/Result:} Returns an Enum representing the server state. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to check the server status. \\
        \textbf{How test will be performed:} The tester will call the function and check if the server status is returned as expected. \\

  \item \textbf{Name:} buildURL \label{itm:Test-RAC-BU} \\
        \textbf{Test ID:} Test-RAC-BU \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} Takes the endpoint as a string and the query parameters as a list of strings. \\
        \textbf{Output/Result:} Returns the complete URL with the base URL, the endpoint and the query parameters. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to build a URL for the HTTP request. \\
        \textbf{How test will be performed:} The tester will call the function with the appropriate parameters and check if the URL is built as expected. \\

  \item \textbf{Name:} logRequest \label{itm:Test-RAC-LR} \\
        \textbf{Test ID:} Test-RAC-LR \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} An HTTP request has been made. \\
        \textbf{Input/Condition:} A string representing the request details. \\
        \textbf{Output/Result:} No output is expected and the log should be written to the application's log terminal. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to log requests made to server. \\
        \textbf{How test will be performed:} The tester will call the function with the appropriate request details and check if the log is written to the application's log terminal. \\

\end{enumerate}

\subsection{Realm Interface}

\begin{enumerate}

  \item \textbf{Name:} renderObjects \label{itm:Test-RI-RO} \\
        \textbf{Test ID:} Test-RI-RO \\
        \textbf{Type:} Automatic \\
        \textbf{Initial State:} N/A \\
        \textbf{Input/Condition:} A list of 3D objects that need to be rendered. \\
        \textbf{Output/Result:} No output is expected. \\
        \textbf{Test Case Derivation:} This test case is derived from the requirement to render objects in the realm. \\
        \textbf{How test will be performed:} The tester will call the function with the appropriate 3D objects and check if the objects are rendered in the realm. \\

\end{enumerate}

\subsection{Authentication Module}

\subsubsection{SendNotification}

\textbf{Name:} SendNotification \label{itm:Test-AM-SN} \\
\textbf{Test ID:} Test-AM-SN \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, and the test environment has a known valid user ID. \\
\textbf{Input/Condition:} User ID, notification message \\
\textbf{Output/Result:}  Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that notifications are being sent. We also consider possible edge cases (e.g., invalid user ID or empty message) to ensure correct behavior or exception handling.\\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Manually invoke \textbf{SendNotification} with a valid user ID and a non-empty message.
    \item Verify that the function returns true (success).
    \item Repeat with an invalid user ID or empty message to ensure it returns false or throws an exception. 
    \item Document all outcomes and compare against expected results.
\end{enumerate}\\

\subsubsection{FetchNotifications}
\noindent
\textbf{Name:} FetchNotifications \label{itm:Test-AM-FN} \\
\textbf{Test ID:} Test-AM-FN \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and the test environment has a known valid user ID. \\
\textbf{Input/Condition:} User ID \\
\textbf{Output/Result:} List of notifications \\
\textbf{Test Case Derivation:} Testing that a list of notifications can be received. We also consider edge cases to ensure correct behavior or exception handling.\\
\textbf{How test will be performed:} Manually invoke FetchNotifications with a valid user ID that is known to have notifications and verify that the function returns the expected list of notifications.

\subsubsection{MarkNotificationRead}
\noindent
\textbf{Name:} MarkNotificationRead \label{itm:Test-AM-MNR} \\
\textbf{Test ID:} Test-AM-MNR \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and the test environment has a known valid notification ID. \\
\textbf{Input/Condition:} Notification ID \\
\textbf{Output/Result:} Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that a notification can be marked as read. We also consider edge cases to ensure correct behavior or exception handling.\\
\textbf{How test will be performed:} Receive a notification and mark it as read. Check if the database reflected this notification as read. \\ \\

\subsubsection{DeleteNotification}
\textbf{Name:} DeleteNotification \label{itm:Test-AM-DN} \\
\textbf{Test ID:} Test-AM-DN \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and the test environment has a known valid notification ID that can be deleted. \\
\textbf{Input/Condition:} Notification ID \\
\textbf{Output/Result:} Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that a notification can be deleted. We also consider edge cases (e.g., invalid notification ID) to ensure correct behavior or exception handling.\\
\textbf{How test will be performed:} Receive a notification and then go in and delete it and see if it is still stored or if it is actually deleted. \\

\subsubsection{UpdateNotificationSettings}
\textbf{Name:} UpdateNotificationSettings \label{itm:Test-AM-UNS} \\
\textbf{Test ID:} Test-AM-UNS \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and the test environment has a known valid user ID and default notification settings. \\
\textbf{Input/Condition:} User ID, settings data \\
\textbf{Output/Result:} Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that a user's notification settings can be updated. We also consider edge cases (e.g., invalid settings data) to ensure correct behavior or exception handling.\\
\textbf{How test will be performed:} Modify some settings regarding notifications (such as notification sound), and then manually receive a notification and verify that the change worked. \\

\subsection{Object Render Module}

\subsubsection{FetchRenderSettings}

\textbf{Name:} FetchRenderSettings \label{itm:Test-AM-FRS} \\
\textbf{Test ID:} Test-AM-FRS \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running with a default or previously configured set of render settings. \\
\textbf{Input/Condition:} - \\
\textbf{Output/Result:} Dictionary of current render settings \\
\textbf{Test Case Derivation:} Testing that the function retrieves the current render settings without requiring any input. We also consider the default configuration scenario to ensure correct behavior.\\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Invoke FetchRenderSettings in a running system.
    \item Confirm that it returns a valid dictionary of render settings matching the current configuration.
\end{enumerate}

\subsection{Touring Module}

\subsubsection{StartTour}
\textbf{Name:} StartTour \label{itm:Test-TM-ST} \\
\textbf{Test ID:} Test-TM-ST \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and a valid tour exists but has not started. \\
\textbf{Input/Condition:} Tour ID \\
\textbf{Output/Result:} Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that a tour can be started with a valid Tour ID. We also consider edge cases (e.g., invalid Tour ID) to ensure correct behavior or exception handling. \\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Invoke \textbf{StartTour} with a valid Tour ID and confirm it returns \texttt{true}.
    \item Invoke \textbf{StartTour} with an invalid Tour ID and confirm it throws an InvalidTourIDException.
\end{enumerate}

\subsubsection{PauseTour}
\textbf{Name:} PauseTour \label{itm:Test-TM-PT} \\
\textbf{Test ID:} Test-TM-PT \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and a tour is currently active. \\
\textbf{Input/Condition:} - \\
\textbf{Output/Result:} Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that an active tour can be paused without any specific input. \\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Start a tour using \textbf{StartTour}.
    \item Invoke \textbf{PauseTour} and confirm it returns \texttt{true}.
    \item Verify that the tours state changes to a paused state in the system.
\end{enumerate}

\subsubsection{EndTour}
\textbf{Name:} EndTour \label{itm:Test-TM-ET} \\
\textbf{Test ID:} Test-TM-ET \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and a tour is currently active or paused. \\
\textbf{Input/Condition:} - \\
\textbf{Output/Result:} Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that an active or paused tour can be ended. \\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Start a tour using \textbf{StartTour}
    \item Invoke \textbf{EndTour} and confirm it returns true.
\end{enumerate}

\subsubsection{FetchTourDetails}
\textbf{Name:} FetchTourDetails \label{itm:Test-TM-FTD} \\
\textbf{Test ID:} Test-TM-FTD \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and at least one valid tour ID is known. \\
\textbf{Input/Condition:} Tour ID \\
\textbf{Output/Result:} Tour Object \\
\textbf{Test Case Derivation:} Testing that the function retrieves detailed information about a specific tour. \\
\textbf{How test will be performed:} Invoke \textbf{FetchTourDetails} with a valid Tour ID and verify it returns the correct Tour Object.

 \subsection{Tour LIst Module}

 \subsubsection{FetchTourList}
\textbf{Name:} FetchTourList \label{itm:Test-TM-FTL} \\
\textbf{Test ID:} Test-TM-FTL \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in. \\
\textbf{Input/Condition:} None \\
\textbf{Output/Result:} Array of Tours \\
\textbf{Test Case Derivation:} Testing that a list of all available tours can be fetched without any specific input. \\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Invoke \textbf{FetchTourList} in a running system.
    \item Verify that it returns an \textit{Array of Tours} containing all currently available tours.
\end{enumerate}

\subsubsection{SearchTours}
\textbf{Name:} SearchTours \label{itm:Test-TM-STQ} \\
\textbf{Test ID:} Test-TM-STQ \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and there are multiple tours available. \\
\textbf{Input/Condition:} Search Query \\
\textbf{Output/Result:} Array of Tours \\
\textbf{Test Case Derivation:} Testing that the function can return tours filtered by a given search query. We also consider edge cases, like an empty or irrelevant query. \\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Invoke \textbf{SearchTours} with a valid query (e.g., a known keyword).
    \item Verify that the returned \textit{Array of Tours} matches the search criteria.
    \item Invoke \textbf{SearchTours} with an empty or irrelevant query to ensure it returns an empty array or no matching results.
\end{enumerate}

\subsection{Tour Management Module}
\subsubsection{CreateTour}
\textbf{Name:} CreateTour \label{itm:Test-TM-CT} \\
\textbf{Test ID:} Test-TM-CT \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and the environment allows creation of new tours. \\
\textbf{Input/Condition:} Tour Object \\
\textbf{Output/Result:} Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that a new tour can be created with valid tour data. We also consider edge cases (e.g., invalid tour data) to ensure correct behavior or exception handling (e.g., \textbf{InvalidTourDataException}).\\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Invoke \textbf{CreateTour} with a valid Tour Object and verify it returns true.
    \item Invoke \textbf{CreateTour} with invalid tour data to ensure it throws InvalidTourDataException.
\end{enumerate}

\subsubsection{UpdateTour}
\textbf{Name:} UpdateTour \label{itm:Test-TM-UT} \\
\textbf{Test ID:} Test-TM-UT \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and at least one valid tour exists. \\
\textbf{Input/Condition:} Tour ID, Updated Tour Data \\
\textbf{Output/Result:} Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that an existing tour can be updated with new data. We also consider edge cases (e.g., invalid Tour ID) to ensure correct behavior or exception handling (e.g., \textbf{InvalidTourIDException}).\\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Invoke UpdateTour with a valid Tour ID and valid updated tour data. Verify it returns true.
    \item Invoke UpdateTour with an invalid Tour ID to ensure it throws InvalidTourIDException.
\end{enumerate}

\subsubsection{DeleteTour}
\textbf{Name:} DeleteTour \label{itm:Test-TM-DT} \\
\textbf{Test ID:} Test-TM-DT \\
\textbf{Type:} Manual \\
\textbf{Initial State:} System is running, user is logged in, and at least one valid tour ID is known. \\
\textbf{Input/Condition:} Tour ID \\
\textbf{Output/Result:} Bool - Success or Fail \\
\textbf{Test Case Derivation:} Testing that an existing tour can be deleted with a valid tour ID. We also consider edge cases (e.g., invalid Tour ID) to ensure correct behavior or exception handling (e.g., \textbf{InvalidTourIDException}).\\
\textbf{How test will be performed:}
\begin{enumerate}
    \item Invoke DeleteTour with a valid Tour ID and confirm it returns true.
    \item Invoke DeleteTour with an invalid Tour ID to ensure it throws InvalidTourIDException.
\end{enumerate}


\printbibliography



\newpage

\section{Appendix}

This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Usability Survey Questions} \label{sub:usability_survey}

\begin{itemize}
  \item For the following statements, please indicate your level of agreement between Strongly Disagree, Disagree, Neither Agree nor Disagree, Agree, and Strongly Agree:
        \begin{itemize}
          \item Navigating between interfaces is intuitive
          \item Placing objects is intuitive
          \item Generating objects by prompt is intuitive
          \item Embarking on tours is intuitive
          \item Creating tours is intuitive (ONLY FOR ORG USERS)
          \item Managing tours is intuitive (ONLY FOR ORG USERS)
          \item Changing user settings is intuitive
          \item Interacting with other's objects is intuitive
          \item Reporting other's objects is intuitive
          \item Using the app is generally satisfying
          \item Using the app is distracting from the surroundings
          \item The app is compatible with, and works well on, my device (Android or IOS)
        \end{itemize}
  \item Did you experience any service interruptions, including but not limited to excessive load times for elements like navigation and object placement, while testing the app? \\
\end{itemize}

\newpage{}
\section*{Appendix --- Reflection}

The information in this section will be used to evaluate the team members on the
graduate attribute of Lifelong Learning.

\input{../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? \\

        Making the tests were very easy after we had the initial template down and distributed the work effectively amongst ourselves based on the functional and non-functional requirements.

  \item What pain points did you experience during this deliverable, and how did you resolve them?\\

        One pain point we experienced was that we had a lot to do for this deliverable that we couldn't work on the next one, which is POC. Ultimately, what we decided to do was to focus mainly on this, because the deadline is earlier, and focus mainly on getting our project set up for POC. That way, we at least have started on the next deliverable.

        Another thing was deciding which tests to automate and which to make manual. We resolved this by seeing which test would be easiest or quickest to implement. If a manual test was easiest, we would choose that, but if a manual test would take long, we'd make it automated.\\

  \item What knowledge and skills will the team collectively need to acquire to successfully complete the verification and validation of your project? Examples of possible knowledge and skills include dynamic testing knowledge, static testing knowledge, specific tool usage, Valgrind etc. You should look to identify at least one item for each team member.\\

        The team will need to become familiar with C\# tooling like unit test frameworks and compatible static analysis tools.

        For dynamic testing, the team will likely use the \textit{Unity Test Framework} since it is already integrated into the Unity game engine which powers the project. There are also Roslyn analyzers build for the .NET platform that are integrated into IDEs that are connected to Unity. These are useful as static analyzers that can check for errors in the code even if it still compiles.

        As a tentative plan, we will have Russell look into configuring the Roslyn analyzers that come packaged with .NET so that it meets our needs. Abdul and Avanish will research the \textit{Unity Test Framework} for the Unity \textit{Editor Mode} and \textit{Play Mode} respectively. Rafey will pick a static analysis tool like SonarQube for us to use the code.

  \item For each of the knowledge areas and skills identified in the previous question, what are at least two approaches to acquiring the knowledge or mastering the skill?  Of the identified approaches, which will each team member pursue, and why did they make this choice? \\

        One approach (especially given the popularity of Unity/.NET/SonarQube) is to watch videos online where people talk about the testing within the context of Unity projects. This could give us a prospective on how other people implement testing. Another approach is to read through the documentation associated with the topic at hand. This is very useful when a there is a smaller user base for a tool and no associated videos or examples.

        Russell will read documentation since most of his work surrounds configuration which requires a description for each configurable part. This is easily searchable when sifting through documentation.

        Abdul and Avanish will watch videos (if they can find some good ones) about the \textit{Unity Test Framework}. Since it is a very popular among game developers who use Unity, there should be many walkthroughs on how to use it. By watching multiple videos, they should get a sense of how people usually implement the framework for testing.

        Rafey will use Google and look through internet forums to see what other developers recommend when it comes to static analysis for C\#. He will also end up looking at the documentation for these tools to decide which one works the best for our use case.

\end{enumerate}

\end{document}
