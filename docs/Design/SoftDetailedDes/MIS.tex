\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
  \toprule {\bf Date} & {\bf Version} & {\bf Notes} \\
  \midrule
  Date 1              & 1.0           & Notes       \\
  Date 2              & 1.1           & Notes       \\
  \bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
  \Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname.

\begin{center}
  \renewcommand{\arraystretch}{1.2}
  \noindent
  \begin{tabular}{l l p{7.5cm}}
    \toprule
    \textbf{Data Type} & \textbf{Notation} & \textbf{Description}                                             \\
    \midrule
    character          & char              & a single symbol or digit                                         \\
    integer            & $\mathbb{Z}$      & a number without a fractional component in (-$\infty$, $\infty$) \\
    natural number     & $\mathbb{N}$      & a number without a fractional component in [1, $\infty$)         \\
    real               & $\mathbb{R}$      & any number in (-$\infty$, $\infty$)                              \\
    \bottomrule
  \end{tabular}
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
  \centering
  \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
    \toprule
    \textbf{Level 1}                               & \textbf{Level 2}                \\
    \midrule

    {Hardware-Hiding}                              & ~                               \\
    \midrule

    \multirow{7}{0.3\textwidth}{Behaviour-Hiding}  & Input Parameters                \\
                                                   & Output Format                   \\
                                                   & Output Verification             \\
                                                   & Temperature ODEs                \\
                                                   & Energy Equations                \\
                                                   & Control Module                  \\
                                                   & Specification Parameters Module \\
    \midrule

    \multirow{3}{0.3\textwidth}{Software Decision} & {Sequence Data Structure}       \\
                                                   & ODE Solver                      \\
                                                   & Plotting                        \\
    \bottomrule
  \end{tabular}
  \caption{Module Hierarchy}
  \label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of Sub-Realms} \label{sub-realms}

\subsection{Module}

SubRealms

\subsection{Uses}

\ref{local-dbm}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
    \hline
    \textbf{Name}  & \textbf{In}                             & \textbf{Out}                            & \textbf{Exceptions}                     \\
    \hline
    getMembers     & $\mathbb{N}$                            & Array\textlangle$\mathbb{N}$\textrangle & SubRealmNotFound                        \\
    addMember      & $\mathbb{N}$, $\mathbb{N}$              & -                                       & SubRealmNotFound, UserAlreadyInSubRealm \\
    removeMember   & $\mathbb{N}$, $\mathbb{N}$              & -                                       & SubRealmNotFound, MemberNotFound        \\
    createNew      & Array\textlangle$\mathbb{N}$\textrangle & $\mathbb{N}$                            & -                                       \\
    deleteExisting & $\mathbb{N}$                            & -                                       & SubRealmNotFound                        \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \( subRealms \): A mapping of \( subRealmID \to subRealm \), where each \( subRealm \) contains a list of \( members \) (user IDs).
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \( localDB \): The local database used for storing sub-realm data temporarily.
\end{itemize}

\subsubsection{Assumptions}

Sub-realm IDs (\( subRealmID \)) are unique, and all user IDs (\( userID \)) are valid.

\subsubsection{Access Routine Semantics}

\noindent getMembers(subRealmID):
\begin{itemize}
  \item \textbf{transition}: N/A
  \item \textbf{output}: Returns the list of \( userIDs \) that are members of the sub-realm identified by \( subRealmID \).
  \item \textbf{exception}:
        \begin{itemize}
          \item \( SubRealmNotFound \): If \( subRealmID \) does not exist.
        \end{itemize}
\end{itemize}

\noindent addMember(subRealmID, userID):
\begin{itemize}
  \item \textbf{transition}:
        If \( subRealmID \in subRealms \) and \( userID \notin subRealms[subRealmID].members \), add \( userID \) to the members of the sub-realm identified by \( subRealmID \).
  \item \textbf{output}: N/A
  \item \textbf{exception}:
        \begin{itemize}
          \item \( SubRealmNotFound \): If \( subRealmID \) does not exist.
          \item \( UserAlreadyInSubRealm \): If \( userID \) is already a member of the sub-realm.
        \end{itemize}
\end{itemize}

\noindent removeMember(subRealmID, userID):
\begin{itemize}
  \item \textbf{transition}:
        If \( subRealmID \in subRealms \) and \( userID \in subRealms[subRealmID].members \), remove \( userID \) from the members of the sub-realm identified by \( subRealmID \).
  \item \textbf{output}: N/A
  \item \textbf{exception}:
        \begin{itemize}
          \item \( SubRealmNotFound \): If \( subRealmID \) does not exist.
          \item \( MemberNotFound \): If \( userID \) is not a member of the sub-realm.
        \end{itemize}
\end{itemize}

\noindent createNew(memberList):
\begin{itemize}
  \item \textbf{transition}:
        A new sub-realm is created with a unique \( subRealmID \), and its \( members \) are initialized to \( memberList \).
        The new sub-realm is stored in both the local and server databases.
  \item \textbf{output}: Returns the unique \( subRealmID \) of the newly created sub-realm.
  \item \textbf{exception}: None
\end{itemize}

\noindent deleteExisting(subRealmID):
\begin{itemize}
  \item \textbf{transition}:
        If \( subRealmID \in subRealms \), remove the sub-realm from both the local and server databases.
  \item \textbf{output}: N/A
  \item \textbf{exception}:
        \begin{itemize}
          \item \( SubRealmNotFound \): If \( subRealmID \) does not exist.
        \end{itemize}
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{syncWithLocalDB()}: Synchronizes sub-realm data with the local database.
  \item \texttt{syncWithServerDB()}: Synchronizes sub-realm data with the server database.
\end{itemize}


\newpage


\section{MIS of Maps} \label{maps}

\subsection{Module}

Maps

\subsection{Uses}

\ref{local-dbm}, Google Maps API

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{4cm} p{3cm} p{3cm} p{4cm}}
    \hline
    \textbf{Name} & \textbf{In}                     & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    getMapData    & $\mathbb{N}$                    & MapData      & LocationNotFound    \\
    addMarker     & $\mathbb{N}$, Location, Details & -            & -                   \\
    removeMarker  & $\mathbb{N}$, Location          & -            & MarkerNotFound      \\
    updateMarker  & $\mathbb{N}$, Location, Details & -            & MarkerNotFound      \\
    displayMap    & $\mathbb{N}$                    & RenderedMap  & LocationNotFound    \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \( markers \): A collection of markers, where each marker includes its \( Location \) and associated \( Details \).
  \item \( mapViews \): A mapping from \( \mathbb{N} \) (view IDs) to rendered map states.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item Access to the Google Maps API.
  \item Access to the local database for location details.
\end{itemize}

\subsubsection{Assumptions}

The Google Maps API and the local database are available and functioning properly.

\subsubsection{Access Routine Semantics}

\noindent getMapData(viewID):
\begin{itemize}
  \item \textbf{transition}: N/A
  \item \textbf{output}: Returns \( MapData \) for the \( viewID \), including all markers and details for the associated location.
  \item \textbf{exception}: \( viewID \notin mapViews \)
\end{itemize}

\noindent addMarker(viewID, location, details):
\begin{itemize}
  \item \textbf{transition}:
        If \( viewID \in mapViews \), adds a marker to the map at \( location \) with the given \( details \).
  \item \textbf{output}: N/A
  \item \textbf{exception}: None
\end{itemize}

\noindent removeMarker(viewID, location):
\begin{itemize}
  \item \textbf{transition}:
        If \( location \in markers[viewID] \), removes the marker at \( location \) from the map.
  \item \textbf{output}: N/A
  \item \textbf{exception}: \( location \notin markers[viewID] \)
\end{itemize}

\noindent updateMarker(viewID, location, details):
\begin{itemize}
  \item \textbf{transition}:
        If \( location \in markers[viewID] \), updates the marker at \( location \) with new \( details \).
  \item \textbf{output}: N/A
  \item \textbf{exception}: \( location \notin markers[viewID] \)
\end{itemize}

\noindent displayMap(viewID):
\begin{itemize}
  \item \textbf{transition}:
        Renders the map for the \( viewID \), including all markers and relevant details.
  \item \textbf{output}: Returns \( RenderedMap \), which is a visual representation of the map.
  \item \textbf{exception}: \( viewID \notin mapViews \)
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{fetchLocationDetails(Location)}: Communicates with the local database to retrieve detailed information for a given location.
  \item \texttt{renderMap(viewID)}: Generates a visual representation of the map for the given \( viewID \) using the Google Maps API.
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{MIS of Object Interaction Module} \label{object-interaction}

\subsection{Module}

ObjectInteraction

\subsection{Uses}

\ref{local-dbm}, AR Object Renderer, Notification System

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
    \hline
    \textbf{Name}  & \textbf{In}                     & \textbf{Out}                         & \textbf{Exceptions} \\
    \hline
    reportObject   & $\mathbb{N}$, Reason, Details   & -                                    & ObjectNotFound      \\
    reactToObject  & $\mathbb{N}$, Reaction          & -                                    & ObjectNotFound      \\
    fetchReactions & $\mathbb{N}$                    & Array\textlangle Reaction\textrangle & ObjectNotFound      \\
    fetchReports   & $\mathbb{N}$                    & Array\textlangle Report\textrangle   & ObjectNotFound      \\
    resolveReport  & $\mathbb{N}$, ResolutionDetails & -                                    & ReportNotFound      \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \( objects \): A collection of AR objects, each identified by a unique \( \mathbb{N} \).
  \item \( reports \): A collection of reports associated with AR objects, including \( Reason \) and \( Details \).
  \item \( reactions \): A collection of user reactions, associated with specific AR objects.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item AR objects are rendered and interactable in the environment.
  \item The system must have a connection to the local database for storing reports and reactions.
\end{itemize}

\subsubsection{Assumptions}

All AR objects are assigned unique identifiers and are interactable within the system. Users have access to a predefined set of reaction types (e.g., Like, Dislike).

\subsubsection{Access Routine Semantics}

\noindent reportObject(objectID, reason, details):
\begin{itemize}
  \item \textbf{transition}:
        Adds a new report to \( reports \) for the object identified by \( objectID \), with the specified \( reason \) and \( details \).
  \item \textbf{output}: N/A
  \item \textbf{exception}: \( objectID \notin objects \)
\end{itemize}

\noindent reactToObject(objectID, reaction):
\begin{itemize}
  \item \textbf{transition}:
        Adds a \( reaction \) (e.g., Like, Dislike) to \( reactions \) for the object identified by \( objectID \).
  \item \textbf{output}: N/A
  \item \textbf{exception}: \( objectID \notin objects \)
\end{itemize}

\noindent fetchReactions(objectID):
\begin{itemize}
  \item \textbf{transition}: N/A
  \item \textbf{output}: Returns all \( reactions \) associated with \( objectID \).
  \item \textbf{exception}: \( objectID \notin objects \)
\end{itemize}

\noindent fetchReports(objectID):
\begin{itemize}
  \item \textbf{transition}: N/A
  \item \textbf{output}: Returns all \( reports \) associated with \( objectID \).
  \item \textbf{exception}: \( objectID \notin objects \)
\end{itemize}

\noindent resolveReport(reportID, resolutionDetails):
\begin{itemize}
  \item \textbf{transition}:
        Marks the \( report \) identified by \( reportID \) as resolved and stores the \( resolutionDetails \).
  \item \textbf{output}: N/A
  \item \textbf{exception}: \( reportID \notin reports \)
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{validateObject(objectID)}: Ensures \( objectID \) corresponds to a valid AR object in the system.
  \item \texttt{notifyUser(reportID)}: Sends a notification to the user who submitted the report, indicating its resolution status.
\end{itemize}

\newpage

\section{MIS of Local Database Manager} \label{local-dbm}

\subsection{Module}

LocalDBM

\subsection{Uses}

\ref{server-dbm}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
    \hline
    \textbf{Name}  & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    fetchData      & Query       & Data         & DataNotFound        \\
    saveData       & Key, Data   & -            & -                   \\
    updateData     & Key, Data   & -            & DataNotFound        \\
    deleteData     & Key         & -            & DataNotFound        \\
    syncWithServer & -           & -            & ServerError         \\
    getCachedData  & Key         & Data         & DataNotCached       \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \( localCache \): A local in-memory or on-disk cache, keyed by unique \( Key \), storing frequently accessed data.
  \item \( lastSyncTime \): A timestamp of the last successful synchronization with the server database.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item Access to the server database for retrieving and storing persistent data.
  \item A local caching mechanism (e.g., in-memory cache or local storage).
\end{itemize}

\subsubsection{Assumptions}

The server database is available and operational for syncing, and the local caching system has sufficient storage capacity.

\subsubsection{Access Routine Semantics}

\noindent fetchData(query):
\begin{itemize}
  \item \textbf{transition}: N/A
  \item \textbf{output}: Executes \( query \) on the local cache or the server database if the data is not cached, and returns the \( Data \).
  \item \textbf{exception}: Returns \( DataNotFound \) if the query does not match any records.
\end{itemize}

\noindent saveData(key, data):
\begin{itemize}
  \item \textbf{transition}:
        Stores \( data \) in the \( localCache \) with the associated \( key \). Also updates the server database asynchronously.
  \item \textbf{output}: N/A
  \item \textbf{exception}: None
\end{itemize}

\noindent updateData(key, data):
\begin{itemize}
  \item \textbf{transition}:
        Updates \( data \) in \( localCache \) and synchronizes the change to the server database.
  \item \textbf{output}: N/A
  \item \textbf{exception}: \( key \notin localCache \)
\end{itemize}

\noindent deleteData(key):
\begin{itemize}
  \item \textbf{transition}:
        Removes \( data \) identified by \( key \) from \( localCache \) and the server database.
  \item \textbf{output}: N/A
  \item \textbf{exception}: \( key \notin localCache \)
\end{itemize}

\noindent syncWithServer():
\begin{itemize}
  \item \textbf{transition}:
        Synchronizes the \( localCache \) with the server database, updating any stale or missing records.
  \item \textbf{output}: N/A
  \item \textbf{exception}: \( ServerError \) if the server database is unavailable or the synchronization fails.
\end{itemize}

\noindent getCachedData(key):
\begin{itemize}
  \item \textbf{transition}: N/A
  \item \textbf{output}: Returns \( data \) from \( localCache \) associated with \( key \).
  \item \textbf{exception}: \( key \notin localCache \)
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{isCacheStale(key)}: Determines whether the cached data for \( key \) is outdated compared to the server database.
  \item \texttt{resolveConflict(localData, serverData)}: Resolves discrepancies between \( localCache \) and server database data.
\end{itemize}

\newpage

\section{MIS of Server Database Manager} \label{server-dbm}

\subsection{Module}

ServerDBM

\subsection{Uses}

\ref{local-dbm}

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}        \\
    \hline
    fetchData     & Query       & Data         & DataNotFound, NetworkError \\
    saveData      & Key, Data   & -            & NetworkError               \\
    updateData    & Key, Data   & -            & DataNotFound, NetworkError \\
    deleteData    & Key         & -            & DataNotFound, NetworkError \\
    syncWithLocal & DataDiff    & -            & NetworkError               \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \( database \): The server database that stores all permanent data associated with the app.
  \item \( lastSyncTime \): A timestamp indicating the last synchronization with the local database.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item Network connectivity must be available for communication between the server database and local database manager.
\end{itemize}

\subsubsection{Assumptions}

The server database is accessible, operational, and synchronized with the local database manager periodically.

\subsubsection{Access Routine Semantics}

\noindent fetchData(query):
\begin{itemize}
  \item \textbf{transition}: N/A
  \item \textbf{output}: Executes \( query \) on the server database and returns the corresponding \( Data \).
  \item \textbf{exception}:
        \begin{itemize}
          \item \( DataNotFound \): If \( query \) does not match any records in the database.
          \item \( NetworkError \): If the network connection fails.
        \end{itemize}
\end{itemize}

\noindent saveData(key, data):
\begin{itemize}
  \item \textbf{transition}:
        Adds \( data \) to the server database with the associated \( key \).
  \item \textbf{output}: N/A
  \item \textbf{exception}:
        \begin{itemize}
          \item \( NetworkError \): If the network connection fails.
        \end{itemize}
\end{itemize}

\noindent updateData(key, data):
\begin{itemize}
  \item \textbf{transition}:
        Updates \( data \) in the server database associated with \( key \).
  \item \textbf{output}: N/A
  \item \textbf{exception}:
        \begin{itemize}
          \item \( DataNotFound \): If \( key \) does not exist in the database.
          \item \( NetworkError \): If the network connection fails.
        \end{itemize}
\end{itemize}

\noindent deleteData(key):
\begin{itemize}
  \item \textbf{transition}:
        Removes the record associated with \( key \) from the server database.
  \item \textbf{output}: N/A
  \item \textbf{exception}:
        \begin{itemize}
          \item \( DataNotFound \): If \( key \) does not exist in the database.
          \item \( NetworkError \): If the network connection fails.
        \end{itemize}
\end{itemize}

\noindent syncWithLocal(dataDiff):
\begin{itemize}
  \item \textbf{transition}:
        Synchronizes the \( database \) with changes provided in \( dataDiff \) from the local database manager.
  \item \textbf{output}: N/A
  \item \textbf{exception}:
        \begin{itemize}
          \item \( NetworkError \): If the network connection fails during synchronization.
        \end{itemize}
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{applyDataDiff(dataDiff)}: Applies the changes from \( dataDiff \) to the server database during synchronization.
  \item \texttt{logSyncOperation(status)}: Logs the success or failure of the synchronization operation.
\end{itemize}

\newpage

\section{MIS of REST API Communication Module} \label{rest-api}

\subsection{Module}

RESTAPICommunication

\subsection{Uses}

\ref{server-dbm}, HTTP Client Library (external)

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{5cm} p{4cm} p{3cm} p{3cm}}
    \hline
    \textbf{Name}        & \textbf{In}              & \textbf{Out}   & \textbf{Exceptions}    \\
    \hline
    sendRequest          & Endpoint, Method, Params & Response       & APIError, NetworkError \\
    parseResponse        & RawResponse              & ParsedResponse & ResponseParsingError   \\
    setHeaders           & Headers                  & -              & -                      \\
    handleAuthentication & AuthToken                & -              & AuthError              \\
    checkServerStatus    & -                        & ServerStatus   & APIError, NetworkError \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \( baseURL \): The base URL for the REST API server.
  \item \( headers \): Key-value pairs for HTTP headers, including authentication tokens and content type.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item Network connectivity for sending HTTP requests to the REST API server.
\end{itemize}

\subsubsection{Assumptions}

The REST API server follows standard HTTP and REST conventions, and the API endpoints are well-documented and accessible.

\subsubsection{Access Routine Semantics}

\noindent sendRequest(endpoint, method, params):
\begin{itemize}
  \item \textbf{transition}:
        Sends an HTTP request to the API server at \( baseURL + endpoint \) using the specified HTTP \( method \) (e.g., GET, POST, PUT, DELETE) and \( params \) as query parameters or request body.
  \item \textbf{output}:
        Returns the \( Response \) received from the API server.
  \item \textbf{exception}:
        \begin{itemize}
          \item \( APIError \): If the server responds with an error status code (e.g., 4xx or 5xx).
          \item \( NetworkError \): If the request fails due to network issues.
        \end{itemize}
\end{itemize}

\noindent parseResponse(rawResponse):
\begin{itemize}
  \item \textbf{transition}: N/A
  \item \textbf{output}:
        Converts \( rawResponse \) (raw HTTP response) into a structured \( ParsedResponse \) (e.g., JSON or XML object).
  \item \textbf{exception}:
        \begin{itemize}
          \item \( ResponseParsingError \): If the \( rawResponse \) cannot be parsed due to invalid format.
        \end{itemize}
\end{itemize}

\noindent setHeaders(headers):
\begin{itemize}
  \item \textbf{transition}:
        Updates the \( headers \) used for subsequent HTTP requests.
  \item \textbf{output}: N/A
  \item \textbf{exception}: None
\end{itemize}

\noindent handleAuthentication(authToken):
\begin{itemize}
  \item \textbf{transition}:
        Sets the authentication token in the \( headers \) for authorized requests.
  \item \textbf{output}: N/A
  \item \textbf{exception}:
        \begin{itemize}
          \item \( AuthError \): If the \( authToken \) is invalid or rejected by the server.
        \end{itemize}
\end{itemize}

\noindent checkServerStatus():
\begin{itemize}
  \item \textbf{transition}: N/A
  \item \textbf{output}:
        Returns the \( ServerStatus \) indicating whether the API server is reachable and operational.
  \item \textbf{exception}:
        \begin{itemize}
          \item \( APIError \): If the server responds with an error status code.
          \item \( NetworkError \): If the request fails due to network issues.
        \end{itemize}
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{buildURL(endpoint, params)}: Constructs the complete URL for the API request by appending \( endpoint \) to \( baseURL \) and encoding \( params \) as query parameters.
  \item \texttt{logRequest(requestDetails)}: Logs details of the outgoing API request for debugging purposes.
  \item \texttt{retryRequest(requestDetails)}: Attempts to resend a failed request based on the retry policy.
\end{itemize}

\newpage





\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable?
  \item What pain points did you experience during this deliverable, and how
        did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
        or a proxy (e.g. your peers, stakeholders, potential users)? For those that
        were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
        requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
        unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
        are the benefits and tradeoffs of those other designs compared with the chosen
        design?  From all the potential options, why did you select the documented design?
        (LO\_Explores)
\end{enumerate}


\end{document}